<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Eigen: Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css"   rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
<!-- <script type="text/javascript"> -->
<!-- </script> -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <a name="top"></a> -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen</a>
   &#160;<span id="projectnumber">3.2.4</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classEigen_1_1Matrix.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classEigen_1_1Matrix-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__Core__Module.html">Core module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows, int _MaxCols&gt;<br/>
class Eigen::Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt;</h3>

<p>The matrix class, also used for vectors and row-vectors. </p>
<p>The Matrix class is the work-horse for all <em>dense</em> (<a class="el" href="classEigen_1_1Matrix.html#dense">note</a>) matrices and vectors within <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library. ">Eigen</a>. Vectors are matrices with one column, and row-vectors are matrices with one row.</p>
<p>The Matrix class encompasses <em>both</em> fixed-size and dynamic-size objects (<a class="el" href="classEigen_1_1Matrix.html#fixedsize">note</a>).</p>
<p>The first three template parameters are required: </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Scalar@anchor</td><td>matrix_tparam_scalar Numeric type, e.g. float, double, int or std::complex&lt;float&gt;. User defined sclar types are supported as well (see <a class="el" href="TopicCustomizingEigen.html#user_defined_scalars">here</a>). </td></tr>
    <tr><td class="paramname">_Rows</td><td>Number of rows, or <b>Dynamic</b> </td></tr>
    <tr><td class="paramname">_Cols</td><td>Number of columns, or <b>Dynamic</b> </td></tr>
  </table>
  </dd>
</dl>
<p>The remaining template parameters are optional &ndash; in most cases you don't have to worry about them. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Options@anchor</td><td>matrix_tparam_options A combination of either <b><a class="el" href="group__enums.html#ggac6bea760bc75e449a80b8cc28bf9a2fea1e16fa1b92ed7a058cd4ce7a9a0db044">RowMajor</a></b> or <b><a class="el" href="group__enums.html#ggac6bea760bc75e449a80b8cc28bf9a2feac86184b0e3be936fbfd20249a057a0bf">ColMajor</a></b>, and of either <b><a class="el" href="group__enums.html#ggac6bea760bc75e449a80b8cc28bf9a2fea02a97bb4792f98916a1156a521fa9813">AutoAlign</a></b> or <b><a class="el" href="group__enums.html#ggac6bea760bc75e449a80b8cc28bf9a2fea761c0504a518c7450ed6dfe9eaeab8a6">DontAlign</a></b>. The former controls <a class="el" href="group__TopicStorageOrders.html">storage order</a>, and defaults to column-major. The latter controls alignment, which is required for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size. </td></tr>
    <tr><td class="paramname">_MaxRows</td><td>Maximum number of rows. Defaults to <em>_Rows</em> (<a class="el" href="classEigen_1_1Matrix.html#maxrows">note</a>). </td></tr>
    <tr><td class="paramname">_MaxCols</td><td>Maximum number of columns. Defaults to <em>_Cols</em> (<a class="el" href="classEigen_1_1Matrix.html#maxrows">note</a>).</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library. ">Eigen</a> provides a number of typedefs covering the usual cases. Here are some examples:</p>
<ul>
<li><code>Matrix2d</code> is a 2x2 square matrix of doubles (<code>Matrix&lt;double, 2, 2&gt;</code>) </li>
<li><code>Vector4f</code> is a vector of 4 floats (<code>Matrix&lt;float, 4, 1&gt;</code>) </li>
<li><code>RowVector3i</code> is a row-vector of 3 ints (<code>Matrix&lt;int, 1, 3&gt;</code>)</li>
</ul>
<ul>
<li><code>MatrixXf</code> is a dynamic-size matrix of floats (<code>Matrix&lt;float, Dynamic, Dynamic&gt;</code>) </li>
<li><code>VectorXf</code> is a dynamic-size vector of floats (<code>Matrix&lt;float, Dynamic, 1&gt;</code>)</li>
</ul>
<ul>
<li><code>Matrix2Xf</code> is a partially fixed-size (dynamic-size) matrix of floats (<code>Matrix&lt;float, 2, Dynamic&gt;</code>) </li>
<li><code>MatrixX3d</code> is a partially dynamic-size (fixed-size) matrix of double (<code>Matrix&lt;double, Dynamic, 3&gt;</code>)</li>
</ul>
<p>See <a class="el" href="group__matrixtypedefs.html">this page </a> for a complete list of predefined <em>Matrix</em> and <em>Vector</em> typedefs.</p>
<p>You can access elements of vectors and matrices using normal subscripting:</p>
<div class="fragment"><div class="line">* <a class="code" href="classEigen_1_1Matrix.html">Eigen::VectorXd</a> v(10);</div>
<div class="line">* v[0] = 0.1;</div>
<div class="line">* v[1] = 0.2;</div>
<div class="line">* v(0) = 0.3;</div>
<div class="line">* v(1) = 0.4;</div>
<div class="line">*</div>
<div class="line">* <a class="code" href="classEigen_1_1Matrix.html">Eigen::MatrixXi</a> m(10, 10);</div>
<div class="line">* m(0, 1) = 1;</div>
<div class="line">* m(0, 2) = 2;</div>
<div class="line">* m(0, 3) = 3;</div>
<div class="line">* </div>
</div><!-- fragment --><p>This class can be extended with the help of the plugin mechanism described on the page <a class="el" href="TopicCustomizingEigen.html">Customizing/Extending Eigen</a> by defining the preprocessor symbol <code>EIGEN_MATRIX_PLUGIN</code>.</p>
<p><em><b>Some notes:</b></em></p>
<dl>
<dt><b><a class="anchor" id="dense"></a><a class="el" href="structEigen_1_1Dense.html">Dense</a> versus sparse:</b> </dt>
<dd><p class="startdd">This Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the <a class="el" href="structEigen_1_1Sparse.html">Sparse</a> module.</p>
<p><a class="el" href="structEigen_1_1Dense.html">Dense</a> matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array. This is unlike <a class="el" href="structEigen_1_1Sparse.html">Sparse</a> matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</p>
<p class="enddd"></p>
</dd>
<dt><b><a class="anchor" id="fixedsize"></a>Fixed-size versus dynamic-size:</b> </dt>
<dd><p class="startdd">Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library. ">Eigen</a> allocates the array of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.</p>
<p>Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime variables, and the array of coefficients is allocated dynamically on the heap.</p>
<p>Note that <em>dense</em> matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map. If you want this behavior, see the <a class="el" href="structEigen_1_1Sparse.html">Sparse</a> module.</p>
<p class="enddd"></p>
</dd>
<dt><b><a class="anchor" id="maxrows"></a>_MaxRows and _MaxCols:</b> </dt>
<dd>In most cases, one just leaves these parameters to the default values. These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols are the dimensions of the original matrix, while _Rows and _Cols are Dynamic. </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> for the majority of the API methods for matrices, <a class="el" href="TopicClassHierarchy.html">The class hierarchy</a>, <a class="el" href="group__TopicStorageOrders.html">Storage orders</a> </dd></dl>
</div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classEigen_1_1Matrix__inherit__graph.png" border="0" usemap="#Matrix_3_01__Scalar_00_01__Rows_00_01__Cols_00_01__Options_00_01__MaxRows_00_01__MaxCols_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="Matrix_3_01__Scalar_00_01__Rows_00_01__Cols_00_01__Options_00_01__MaxRows_00_01__MaxCols_01_4_inherit__map" id="Matrix_3_01__Scalar_00_01__Rows_00_01__Cols_00_01__Options_00_01__MaxRows_00_01__MaxCols_01_4_inherit__map">
<area shape="rect" id="node2" href="classEigen_1_1PlainObjectBase.html" title="{PlainObjectBase\&lt; Matrix\l\&lt; _Scalar, _Rows, _Cols,\l _Options, _MaxRows, _MaxCols \&gt; \&gt;\n|# m_storage\l|+ base()\l+ base()\l+ coeff()\l+ coeff()\l+ coeffRef()\l+ coeffRef()\l+ coeffRef()\l+ coeffRef()\l+ cols()\l+ conservativeResize()\land 31 more...\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\l+ Map()\land 14 more...\l# _init2()\l# _init2()\l# _resize_to_match()\l# _set()\l# _set_noalias()\l# _set_selector()\l# _set_selector()\l# _swap()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\l* Map()\land 14 more...\l}" alt="" coords="5,5,248,819"/></map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afa9be5679ab03d785820f2474c5ccc6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea38ab482a62bf46f6ed6dcc4e9dd0dddf">RowsAtCompileTime</a>, 
<br/>
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a>, 
<br/>
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eab30be5c02d7a124ec165d2ab6c5b05ed">SizeAtCompileTime</a>, 
<br/>
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea1264a9a69c437cbe0f8e723d88471c4a">MaxRowsAtCompileTime</a>, 
<br/>
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eac9998fd25639e32ba4d58d67bfff4420">MaxColsAtCompileTime</a>, 
<br/>
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eacf4ecb7db5a851c1ff90ae7621ab3fd1">MaxSizeAtCompileTime</a>, 
<br/>
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea7e22277c8f0a1a76dd0d6c62e366b59f">IsVectorAtCompileTime</a>, 
<br/>
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea96296863b401484bc191339414c90e6b">Flags</a>, 
<br/>
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea247b0f8b0eb0bfd5e253eb1e4b61436b">IsRowMajor</a>
, <br/>
&#160;&#160;<a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea17c43b803133ba4f73b417edcbfb8206">CoeffReadCost</a>
<br/>
 }</td></tr>
<tr class="separator:afa9be5679ab03d785820f2474c5ccc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319e79809d439b8fabeafa27c28c8835"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#a319e79809d439b8fabeafa27c28c8835">Base</a></td></tr>
<tr class="memdesc:a319e79809d439b8fabeafa27c28c8835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class typedef.  <a href="#a319e79809d439b8fabeafa27c28c8835">More...</a><br/></td></tr>
<tr class="separator:a319e79809d439b8fabeafa27c28c8835"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea914316af61df197f21629e14e7870a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a> (void) const </td></tr>
<tr class="separator:aea914316af61df197f21629e14e7870a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dba91a5de689327121c20af5a5c18a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac1dba91a5de689327121c20af5a5c18a">allFinite</a> () const </td></tr>
<tr class="separator:ac1dba91a5de689327121c20af5a5c18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42571e028736ca9103bac8b50f269824"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a42571e028736ca9103bac8b50f269824">any</a> (void) const </td></tr>
<tr class="separator:a42571e028736ca9103bac8b50f269824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4545be7a9af33ba337a4ebb0101395fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a>&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, <br class="typebreak"/>
_Rows, _Cols, _Options, <br class="typebreak"/>
_MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a4545be7a9af33ba337a4ebb0101395fd">array</a> ()</td></tr>
<tr class="separator:a4545be7a9af33ba337a4ebb0101395fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00eb88e0d7599b8a2881715d3e4b35f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; CustomBinaryOp, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt;<br class="typebreak"/>
, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac00eb88e0d7599b8a2881715d3e4b35f">binaryExpr</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other, const CustomBinaryOp &amp;func=CustomBinaryOp()) const</td></tr>
<tr class="separator:ac00eb88e0d7599b8a2881715d3e4b35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbaa2fc7b809720407130f48dfacf8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockCols)</td></tr>
<tr class="separator:a1dbaa2fc7b809720407130f48dfacf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace64451d903a49f7627cb3b87257c801"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ace64451d903a49f7627cb3b87257c801">block</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockCols) const </td></tr>
<tr class="separator:ace64451d903a49f7627cb3b87257c801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e433315822db2811a65e88c70672743"><td class="memTemplParams" colspan="2">template&lt;int BlockRows, int BlockCols&gt; </td></tr>
<tr class="memitem:a3e433315822db2811a65e88c70672743"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, BlockRows, <br class="typebreak"/>
BlockCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3e433315822db2811a65e88c70672743">block</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol)</td></tr>
<tr class="separator:a3e433315822db2811a65e88c70672743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f9466c400c6dc5779380124e37bf7f"><td class="memTemplParams" colspan="2">template&lt;int BlockRows, int BlockCols&gt; </td></tr>
<tr class="memitem:a40f9466c400c6dc5779380124e37bf7f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
BlockRows, BlockCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a40f9466c400c6dc5779380124e37bf7f">block</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol) const </td></tr>
<tr class="separator:a40f9466c400c6dc5779380124e37bf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d35d793f33794df591242d942f98d65"><td class="memTemplParams" colspan="2">template&lt;int BlockRows, int BlockCols&gt; </td></tr>
<tr class="memitem:a9d35d793f33794df591242d942f98d65"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, BlockRows, <br class="typebreak"/>
BlockCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9d35d793f33794df591242d942f98d65">block</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockCols)</td></tr>
<tr class="separator:a9d35d793f33794df591242d942f98d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fc71e26059f25c5a0de1ebbdfe3375"><td class="memTemplParams" colspan="2">template&lt;int BlockRows, int BlockCols&gt; </td></tr>
<tr class="memitem:a13fc71e26059f25c5a0de1ebbdfe3375"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
BlockRows, BlockCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a13fc71e26059f25c5a0de1ebbdfe3375">block</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> blockCols) const </td></tr>
<tr class="separator:a13fc71e26059f25c5a0de1ebbdfe3375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641cf096441faf5ab490c4973c719c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a641cf096441faf5ab490c4973c719c7a">bottomLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="separator:a641cf096441faf5ab490c4973c719c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd00a289a3033ba0802cb55c23910874"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abd00a289a3033ba0802cb55c23910874">bottomLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const </td></tr>
<tr class="separator:abd00a289a3033ba0802cb55c23910874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243a44832e36d2bf5d0d8d17d1505900"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a243a44832e36d2bf5d0d8d17d1505900"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a243a44832e36d2bf5d0d8d17d1505900">bottomLeftCorner</a> ()</td></tr>
<tr class="separator:a243a44832e36d2bf5d0d8d17d1505900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa849b36665dcca6316f05a634e6540"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a7fa849b36665dcca6316f05a634e6540"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7fa849b36665dcca6316f05a634e6540">bottomLeftCorner</a> () const </td></tr>
<tr class="separator:a7fa849b36665dcca6316f05a634e6540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a305fa6d02685ea21c9050617d837d6"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a7a305fa6d02685ea21c9050617d837d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7a305fa6d02685ea21c9050617d837d6">bottomLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="separator:a7a305fa6d02685ea21c9050617d837d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878151caf2ff25ebbc76186485f81207"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a878151caf2ff25ebbc76186485f81207"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a878151caf2ff25ebbc76186485f81207">bottomLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const </td></tr>
<tr class="separator:a878151caf2ff25ebbc76186485f81207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9618f3c9eb4d4c9813ae8f6a8e70c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2b9618f3c9eb4d4c9813ae8f6a8e70c5">bottomRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="separator:a2b9618f3c9eb4d4c9813ae8f6a8e70c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cfa9c974065fc714cdaf7a5fdbe1ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a26cfa9c974065fc714cdaf7a5fdbe1ed">bottomRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const </td></tr>
<tr class="separator:a26cfa9c974065fc714cdaf7a5fdbe1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6563b16b601d9fd66340ab04d101f9d1"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a6563b16b601d9fd66340ab04d101f9d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6563b16b601d9fd66340ab04d101f9d1">bottomRightCorner</a> ()</td></tr>
<tr class="separator:a6563b16b601d9fd66340ab04d101f9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b8870679a8b100f24a8eecf1ac3477"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:aa0b8870679a8b100f24a8eecf1ac3477"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa0b8870679a8b100f24a8eecf1ac3477">bottomRightCorner</a> () const </td></tr>
<tr class="separator:aa0b8870679a8b100f24a8eecf1ac3477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b796ff9732af7ec072455513480bd4"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a13b796ff9732af7ec072455513480bd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a13b796ff9732af7ec072455513480bd4">bottomRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="separator:a13b796ff9732af7ec072455513480bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f1d3781d0dbcf80b79087c5acad5f5"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a10f1d3781d0dbcf80b79087c5acad5f5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a10f1d3781d0dbcf80b79087c5acad5f5">bottomRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const </td></tr>
<tr class="separator:a10f1d3781d0dbcf80b79087c5acad5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe61d23353a75d7034f7b44ff02aaea1"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afe61d23353a75d7034f7b44ff02aaea1">bottomRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="separator:afe61d23353a75d7034f7b44ff02aaea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5959de43ccb180fbd4ad44002441a52"><td class="memItemLeft" align="right" valign="top">ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae5959de43ccb180fbd4ad44002441a52">bottomRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const </td></tr>
<tr class="separator:ae5959de43ccb180fbd4ad44002441a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d50068b3e133e938202f4e23445aba"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ac0d50068b3e133e938202f4e23445aba"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac0d50068b3e133e938202f4e23445aba">bottomRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N)</td></tr>
<tr class="separator:ac0d50068b3e133e938202f4e23445aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75475e30affe582fc16e256741a4f1a"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ab75475e30affe582fc16e256741a4f1a"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab75475e30affe582fc16e256741a4f1a">bottomRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N) const </td></tr>
<tr class="separator:ab75475e30affe582fc16e256741a4f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660200abaf1fc4b888330a37d6132b76"><td class="memItemLeft" align="right" valign="top">internal::cast_return_type<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, <br class="typebreak"/>
_Cols, _Options, _MaxRows, <br class="typebreak"/>
_MaxCols &gt;, const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_cast_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, <br class="typebreak"/>
_Cols, _Options, _MaxRows, <br class="typebreak"/>
_MaxCols &gt; &gt;::Scalar, NewType &gt;<br class="typebreak"/>
, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, <br class="typebreak"/>
_Cols, _Options, _MaxRows, <br class="typebreak"/>
_MaxCols &gt; &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a660200abaf1fc4b888330a37d6132b76">cast</a> () const</td></tr>
<tr class="separator:a660200abaf1fc4b888330a37d6132b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c77695de3b33405f01f2fdf3dc389d"><td class="memItemLeft" align="right" valign="top">ColXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i)</td></tr>
<tr class="separator:a58c77695de3b33405f01f2fdf3dc389d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390f7c534678354959dd587080b82c2c"><td class="memItemLeft" align="right" valign="top">ConstColXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a390f7c534678354959dd587080b82c2c">col</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i) const </td></tr>
<tr class="separator:a390f7c534678354959dd587080b82c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a617f24129ca31a27fe8a67ec20370"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">ConstColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a49a617f24129ca31a27fe8a67ec20370">colwise</a> () const </td></tr>
<tr class="separator:a49a617f24129ca31a27fe8a67ec20370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7ae69362c464b6721adbb47c655874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">ColwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abe7ae69362c464b6721adbb47c655874">colwise</a> ()</td></tr>
<tr class="separator:abe7ae69362c464b6721adbb47c655874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6c2241712d7faf07019a0d86d3fb79"><td class="memItemLeft" align="right" valign="top">ConjugateReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aab6c2241712d7faf07019a0d86d3fb79">conjugate</a> () const</td></tr>
<tr class="separator:aab6c2241712d7faf07019a0d86d3fb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac24a195e3e35ce2d8946cee5873e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#a4ac24a195e3e35ce2d8946cee5873e51">conservativeResize</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> nbRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> nbCols)</td></tr>
<tr class="separator:a4ac24a195e3e35ce2d8946cee5873e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae238393021f2b8298b1fb1c094ccb290"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#ae238393021f2b8298b1fb1c094ccb290">conservativeResize</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> nbRows, NoChange_t)</td></tr>
<tr class="separator:ae238393021f2b8298b1fb1c094ccb290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf58a9ff956976fb3a26d2a0f6a9dc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#abbf58a9ff956976fb3a26d2a0f6a9dc3">conservativeResize</a> (NoChange_t, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> nbCols)</td></tr>
<tr class="separator:abbf58a9ff956976fb3a26d2a0f6a9dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3202c9faf8977ca71a9b53ef4e4cc70b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#a3202c9faf8977ca71a9b53ef4e4cc70b">conservativeResize</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="separator:a3202c9faf8977ca71a9b53ef4e4cc70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55aac6d6465a7c6b67b10aba69a6da54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#a55aac6d6465a7c6b67b10aba69a6da54">conservativeResizeLike</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a55aac6d6465a7c6b67b10aba69a6da54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa671b5ea336ba21a7644d3fa6577ee00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa671b5ea336ba21a7644d3fa6577ee00">count</a> () const </td></tr>
<tr class="separator:aa671b5ea336ba21a7644d3fa6577ee00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d8398a4497e4a888cfc11c51c14a81"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_abs_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ab4d8398a4497e4a888cfc11c51c14a81">cwiseAbs</a> () const</td></tr>
<tr class="separator:ab4d8398a4497e4a888cfc11c51c14a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9cb99dcb93caf0c3c37860aeef30b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_abs2_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#abc9cb99dcb93caf0c3c37860aeef30b2">cwiseAbs2</a> () const</td></tr>
<tr class="separator:abc9cb99dcb93caf0c3c37860aeef30b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2373e043b49396e152523e85b0a2ace8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; std::equal_to&lt; Scalar &gt;<br class="typebreak"/>
, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, <br class="typebreak"/>
_Cols, _Options, _MaxRows, <br class="typebreak"/>
_MaxCols &gt;, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a2373e043b49396e152523e85b0a2ace8">cwiseEqual</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a2373e043b49396e152523e85b0a2ace8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f241762b604c2117232c5c994068bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; std::binder1st<br class="typebreak"/>
&lt; std::equal_to&lt; Scalar &gt;<br class="typebreak"/>
 &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, <br class="typebreak"/>
_Rows, _Cols, _Options, <br class="typebreak"/>
_MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae1f241762b604c2117232c5c994068bb">cwiseEqual</a> (const Scalar &amp;s) const</td></tr>
<tr class="separator:ae1f241762b604c2117232c5c994068bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433cd5f8e17b2662c4081ec798fa54be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_inverse_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a433cd5f8e17b2662c4081ec798fa54be">cwiseInverse</a> () const</td></tr>
<tr class="separator:a433cd5f8e17b2662c4081ec798fa54be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a53029c0ee62fb8875ce3c12151eda"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_max_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt;<br class="typebreak"/>
, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa1a53029c0ee62fb8875ce3c12151eda">cwiseMax</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:aa1a53029c0ee62fb8875ce3c12151eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e985c7a4f692584865b9ec9e7d5780c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_max_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt;<br class="typebreak"/>
, const ConstantReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7e985c7a4f692584865b9ec9e7d5780c">cwiseMax</a> (const Scalar &amp;other) const</td></tr>
<tr class="separator:a7e985c7a4f692584865b9ec9e7d5780c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc17a621f5682e6eba6a1c439174d550"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_min_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt;<br class="typebreak"/>
, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#afc17a621f5682e6eba6a1c439174d550">cwiseMin</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:afc17a621f5682e6eba6a1c439174d550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02d0af0ea867d6b1cc0cc4db0e1d480"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_min_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt;<br class="typebreak"/>
, const ConstantReturnType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac02d0af0ea867d6b1cc0cc4db0e1d480">cwiseMin</a> (const Scalar &amp;other) const</td></tr>
<tr class="separator:ac02d0af0ea867d6b1cc0cc4db0e1d480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f5276480c741953c66498a078ecd30"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; std::not_equal_to&lt; Scalar &gt;<br class="typebreak"/>
, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, <br class="typebreak"/>
_Cols, _Options, _MaxRows, <br class="typebreak"/>
_MaxCols &gt;, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ac3f5276480c741953c66498a078ecd30">cwiseNotEqual</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:ac3f5276480c741953c66498a078ecd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae759f49ab64f4d454e591bf610a09156"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_product_op<br class="typebreak"/>
&lt; typename <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, <br class="typebreak"/>
_Rows, _Cols, _Options, <br class="typebreak"/>
_MaxRows, _MaxCols &gt;::Scalar, <br class="typebreak"/>
typename OtherDerived::Scalar &gt;<br class="typebreak"/>
, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, <br class="typebreak"/>
_Cols, _Options, _MaxRows, <br class="typebreak"/>
_MaxCols &gt;, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae759f49ab64f4d454e591bf610a09156">cwiseProduct</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:ae759f49ab64f4d454e591bf610a09156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36bff7d4e9186e4fbed250b15ad9e36"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_quotient_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt;<br class="typebreak"/>
, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aa36bff7d4e9186e4fbed250b15ad9e36">cwiseQuotient</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:aa36bff7d4e9186e4fbed250b15ad9e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88945ad7d126468c10e299e896bf0d1e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_sqrt_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a88945ad7d126468c10e299e896bf0d1e">cwiseSqrt</a> () const</td></tr>
<tr class="separator:a88945ad7d126468c10e299e896bf0d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dcc334db75411e168691d9bce08c3a"><td class="memItemLeft" align="right" valign="top">const Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a> () const</td></tr>
<tr class="separator:a40dcc334db75411e168691d9bce08c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4663159a1450fa89214b1ab71f7ef5bf"><td class="memItemLeft" align="right" valign="top">Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#a4663159a1450fa89214b1ab71f7ef5bf">data</a> ()</td></tr>
<tr class="separator:a4663159a1450fa89214b1ab71f7ef5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c29f54b9da54e37fbe1756a0da7013"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a41c29f54b9da54e37fbe1756a0da7013">diagonalSize</a> () const</td></tr>
<tr class="separator:a41c29f54b9da54e37fbe1756a0da7013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb26f170dd440dfafe11117cf826334"><td class="memItemLeft" align="right" valign="top">EvalReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6cb26f170dd440dfafe11117cf826334">eval</a> () const </td></tr>
<tr class="separator:a6cb26f170dd440dfafe11117cf826334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98692bec8f3d859f1e7a60eab87ac571"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a98692bec8f3d859f1e7a60eab87ac571">fill</a> (const Scalar &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>)</td></tr>
<tr class="separator:a98692bec8f3d859f1e7a60eab87ac571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbba97b05d9a88657783dfc4f931f3f"><td class="memTemplParams" colspan="2">template&lt;unsigned int Added, unsigned int Removed&gt; </td></tr>
<tr class="memitem:afcbba97b05d9a88657783dfc4f931f3f"><td class="memTemplItemLeft" align="right" valign="top">const Flagged&lt; Derived, Added, <br class="typebreak"/>
Removed &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afcbba97b05d9a88657783dfc4f931f3f">flagged</a> () const </td></tr>
<tr class="separator:afcbba97b05d9a88657783dfc4f931f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa364b60e6a2a124ea7392e4c0550fb4e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1WithFormat.html">WithFormat</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa364b60e6a2a124ea7392e4c0550fb4e">format</a> (const <a class="el" href="structEigen_1_1IOFormat.html">IOFormat</a> &amp;fmt) const </td></tr>
<tr class="separator:aa364b60e6a2a124ea7392e4c0550fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa867b1db3fb2dd56e7072c7684960ff7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa867b1db3fb2dd56e7072c7684960ff7">hasNaN</a> () const </td></tr>
<tr class="separator:aa867b1db3fb2dd56e7072c7684960ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4c5211a2be02bbf477352228b323ae"><td class="memItemLeft" align="right" valign="top">SegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ade4c5211a2be02bbf477352228b323ae">head</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="separator:ade4c5211a2be02bbf477352228b323ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fa0eb5d46891f2345ff7cc9f3fe99b"><td class="memItemLeft" align="right" valign="top">ConstSegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a41fa0eb5d46891f2345ff7cc9f3fe99b">head</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const </td></tr>
<tr class="separator:a41fa0eb5d46891f2345ff7cc9f3fe99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab7d7b04a8ab7fbe7dce61513c70492"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:afab7d7b04a8ab7fbe7dce61513c70492"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afab7d7b04a8ab7fbe7dce61513c70492">head</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N)</td></tr>
<tr class="separator:afab7d7b04a8ab7fbe7dce61513c70492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d574a75a1054b05804862f847ec32de"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a5d574a75a1054b05804862f847ec32de"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType&lt; N &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5d574a75a1054b05804862f847ec32de">head</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N) const </td></tr>
<tr class="separator:a5d574a75a1054b05804862f847ec32de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01069a930197aeca3b13b44bdc426c7b"><td class="memItemLeft" align="right" valign="top">const ImagReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a01069a930197aeca3b13b44bdc426c7b">imag</a> () const</td></tr>
<tr class="separator:a01069a930197aeca3b13b44bdc426c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1032121a2fc5fcc5f006f976413378f8"><td class="memItemLeft" align="right" valign="top">NonConstImagReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a1032121a2fc5fcc5f006f976413378f8">imag</a> ()</td></tr>
<tr class="separator:a1032121a2fc5fcc5f006f976413378f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9791e1914ad8761992e16032d49c54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#acd9791e1914ad8761992e16032d49c54">innerSize</a> () const </td></tr>
<tr class="separator:acd9791e1914ad8761992e16032d49c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158c2184951e6e415c2e9b98db8e8966"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a158c2184951e6e415c2e9b98db8e8966"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a158c2184951e6e415c2e9b98db8e8966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2515d3d813e1355933b6e0def44640"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aed2515d3d813e1355933b6e0def44640">isApproxToConstant</a> (const Scalar &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:aed2515d3d813e1355933b6e0def44640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045c430069e53c7589e71fcc6984c8a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a045c430069e53c7589e71fcc6984c8a8">isConstant</a> (const Scalar &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a045c430069e53c7589e71fcc6984c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b9e8df68a52b2d46cf70c9babf2a16"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a40b9e8df68a52b2d46cf70c9babf2a16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a40b9e8df68a52b2d46cf70c9babf2a16">isMuchSmallerThan</a> (const typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; Scalar &gt;::Real &amp;other, const RealScalar &amp;prec) const </td></tr>
<tr class="separator:a40b9e8df68a52b2d46cf70c9babf2a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa59b5a40da397d905789cf99bce18d5"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:aaa59b5a40da397d905789cf99bce18d5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aaa59b5a40da397d905789cf99bce18d5">isMuchSmallerThan</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:aaa59b5a40da397d905789cf99bce18d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b4423fdfdf0c0644268095c55fe6ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a34b4423fdfdf0c0644268095c55fe6ea">isOnes</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a34b4423fdfdf0c0644268095c55fe6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc0eb069536157ead1d46c660b9622d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6dc0eb069536157ead1d46c660b9622d">isZero</a> (const RealScalar &amp;prec=<a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; Scalar &gt;::dummy_precision()) const </td></tr>
<tr class="separator:a6dc0eb069536157ead1d46c660b9622d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468be7f76aaf518d692d9888a00ad23b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#a468be7f76aaf518d692d9888a00ad23b">lazyAssign</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a468be7f76aaf518d692d9888a00ad23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4288d22b0312944ec93c8c46474ef6"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ace4288d22b0312944ec93c8c46474ef6">leftCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="separator:ace4288d22b0312944ec93c8c46474ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43a2f7ef9b8029727a3e0424fd4e57d"><td class="memItemLeft" align="right" valign="top">ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa43a2f7ef9b8029727a3e0424fd4e57d">leftCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const </td></tr>
<tr class="separator:aa43a2f7ef9b8029727a3e0424fd4e57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af915090ee1e32d74dc6a9037e7b36c5f"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:af915090ee1e32d74dc6a9037e7b36c5f"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af915090ee1e32d74dc6a9037e7b36c5f">leftCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N)</td></tr>
<tr class="separator:af915090ee1e32d74dc6a9037e7b36c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27392d7a73eae182c766938c93c13ef2"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a27392d7a73eae182c766938c93c13ef2"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a27392d7a73eae182c766938c93c13ef2">leftCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N) const </td></tr>
<tr class="separator:a27392d7a73eae182c766938c93c13ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aede62f513da27e6f61ae7a972b4f96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#a3aede62f513da27e6f61ae7a972b4f96">Matrix</a> ()</td></tr>
<tr class="memdesc:a3aede62f513da27e6f61ae7a972b4f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a3aede62f513da27e6f61ae7a972b4f96">More...</a><br/></td></tr>
<tr class="separator:a3aede62f513da27e6f61ae7a972b4f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3727f1c83c30f0b5a0056d7aaa077c4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#a3727f1c83c30f0b5a0056d7aaa077c4b">Matrix</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> dim)</td></tr>
<tr class="memdesc:a3727f1c83c30f0b5a0056d7aaa077c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector or row-vector with given dimension. This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.  <a href="#a3727f1c83c30f0b5a0056d7aaa077c4b">More...</a><br/></td></tr>
<tr class="separator:a3727f1c83c30f0b5a0056d7aaa077c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d02d48777a79061869f20ab216a759f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#a3d02d48777a79061869f20ab216a759f">Matrix</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols)</td></tr>
<tr class="memdesc:a3d02d48777a79061869f20ab216a759f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an uninitialized matrix with <em>rows</em> rows and <em>cols</em> columns.  <a href="#a3d02d48777a79061869f20ab216a759f">More...</a><br/></td></tr>
<tr class="separator:a3d02d48777a79061869f20ab216a759f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac964eda90d804892390151bdf0f2a1c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac964eda90d804892390151bdf0f2a1c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#ac964eda90d804892390151bdf0f2a1c0">Matrix</a> (const Scalar &amp;x, const Scalar &amp;y)</td></tr>
<tr class="memdesc:ac964eda90d804892390151bdf0f2a1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an initialized 2D vector with given coefficients. <br/></td></tr>
<tr class="separator:ac964eda90d804892390151bdf0f2a1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935ed53e9609902a67341245ebc7610"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae935ed53e9609902a67341245ebc7610"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#ae935ed53e9609902a67341245ebc7610">Matrix</a> (const Scalar &amp;x, const Scalar &amp;y, const Scalar &amp;z)</td></tr>
<tr class="memdesc:ae935ed53e9609902a67341245ebc7610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an initialized 3D vector with given coefficients. <br/></td></tr>
<tr class="separator:ae935ed53e9609902a67341245ebc7610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5369f0750f5f1e885976fb598800d6d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5369f0750f5f1e885976fb598800d6d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#a5369f0750f5f1e885976fb598800d6d8">Matrix</a> (const Scalar &amp;x, const Scalar &amp;y, const Scalar &amp;z, const Scalar &amp;w)</td></tr>
<tr class="memdesc:a5369f0750f5f1e885976fb598800d6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an initialized 4D vector with given coefficients. <br/></td></tr>
<tr class="separator:a5369f0750f5f1e885976fb598800d6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d71eee481ee51c202a74804aac59b97"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d71eee481ee51c202a74804aac59b97"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a0d71eee481ee51c202a74804aac59b97"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#a0d71eee481ee51c202a74804aac59b97">Matrix</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a0d71eee481ee51c202a74804aac59b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor copying the value of the expression <em>other</em>. <br/></td></tr>
<tr class="separator:a0d71eee481ee51c202a74804aac59b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e72b7c50059bf70eca50ada11a4cf88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e72b7c50059bf70eca50ada11a4cf88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#a5e72b7c50059bf70eca50ada11a4cf88">Matrix</a> (const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a> &amp;other)</td></tr>
<tr class="memdesc:a5e72b7c50059bf70eca50ada11a4cf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:a5e72b7c50059bf70eca50ada11a4cf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac517028c963cd8f78a1efaf8cb04b462"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac517028c963cd8f78a1efaf8cb04b462"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ac517028c963cd8f78a1efaf8cb04b462"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#ac517028c963cd8f78a1efaf8cb04b462">Matrix</a> (const ReturnByValue&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:ac517028c963cd8f78a1efaf8cb04b462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with in-place evaluation. <br/></td></tr>
<tr class="separator:ac517028c963cd8f78a1efaf8cb04b462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77e097b777eaa2daf25c9292ca15015"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ad77e097b777eaa2daf25c9292ca15015"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#ad77e097b777eaa2daf25c9292ca15015">Matrix</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:ad77e097b777eaa2daf25c9292ca15015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor for generic expressions.  <a href="#ad77e097b777eaa2daf25c9292ca15015">More...</a><br/></td></tr>
<tr class="separator:ad77e097b777eaa2daf25c9292ca15015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f437faa158729792ccbd6f0c023d9a"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a80f437faa158729792ccbd6f0c023d9a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#a80f437faa158729792ccbd6f0c023d9a">Matrix</a> (const <a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a>&lt; OtherDerived, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a> &gt; &amp;r)</td></tr>
<tr class="memdesc:a80f437faa158729792ccbd6f0c023d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a Dim x Dim rotation matrix from the rotation <em>r</em>.  <a href="#a80f437faa158729792ccbd6f0c023d9a">More...</a><br/></td></tr>
<tr class="separator:a80f437faa158729792ccbd6f0c023d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878f0dae18b28d8158c5f1c232edced2"><td class="memItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a878f0dae18b28d8158c5f1c232edced2">maxCoeff</a> () const </td></tr>
<tr class="separator:a878f0dae18b28d8158c5f1c232edced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad851ef369d212dcea81d9cded12dbdd"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:aad851ef369d212dcea81d9cded12dbdd"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aad851ef369d212dcea81d9cded12dbdd">maxCoeff</a> (IndexType *<a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row</a>, IndexType *<a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col</a>) const </td></tr>
<tr class="separator:aad851ef369d212dcea81d9cded12dbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b381dbcb0435c3a34a78abad4726cc3"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:a0b381dbcb0435c3a34a78abad4726cc3"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0b381dbcb0435c3a34a78abad4726cc3">maxCoeff</a> (IndexType *index) const </td></tr>
<tr class="separator:a0b381dbcb0435c3a34a78abad4726cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af2b3991862a079e3efaef3e4d17d96"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0af2b3991862a079e3efaef3e4d17d96">mean</a> () const </td></tr>
<tr class="separator:a0af2b3991862a079e3efaef3e4d17d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4f5da8e2019251ad3ed876d363d5d1"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2d4f5da8e2019251ad3ed876d363d5d1">middleCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> numCols)</td></tr>
<tr class="separator:a2d4f5da8e2019251ad3ed876d363d5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428643f7e51813faa8c8ad89b8282235"><td class="memItemLeft" align="right" valign="top">ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a428643f7e51813faa8c8ad89b8282235">middleCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> numCols) const </td></tr>
<tr class="separator:a428643f7e51813faa8c8ad89b8282235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa257ee10f662780e48cd9cec53bbbb86"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:aa257ee10f662780e48cd9cec53bbbb86"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa257ee10f662780e48cd9cec53bbbb86">middleCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N)</td></tr>
<tr class="separator:aa257ee10f662780e48cd9cec53bbbb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95bf75ae40119637a809d02bf53e4da"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:ad95bf75ae40119637a809d02bf53e4da"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad95bf75ae40119637a809d02bf53e4da">middleCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startCol, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N) const </td></tr>
<tr class="separator:ad95bf75ae40119637a809d02bf53e4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee53d4065b9aa5164ea8e5fe9459a779"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aee53d4065b9aa5164ea8e5fe9459a779">middleRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="separator:aee53d4065b9aa5164ea8e5fe9459a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491f1ff40224dd1aa37d26cb42438cc4"><td class="memItemLeft" align="right" valign="top">ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a491f1ff40224dd1aa37d26cb42438cc4">middleRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const </td></tr>
<tr class="separator:a491f1ff40224dd1aa37d26cb42438cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0876bbd4a94f44008452fd9486cc26c"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:af0876bbd4a94f44008452fd9486cc26c"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af0876bbd4a94f44008452fd9486cc26c">middleRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N)</td></tr>
<tr class="separator:af0876bbd4a94f44008452fd9486cc26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244977920d9254b31da36bb05b0057c6"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a244977920d9254b31da36bb05b0057c6"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a244977920d9254b31da36bb05b0057c6">middleRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> startRow, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N) const </td></tr>
<tr class="separator:a244977920d9254b31da36bb05b0057c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6cb2d85282829eb9adc9565ce784d6"><td class="memItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#add6cb2d85282829eb9adc9565ce784d6">minCoeff</a> () const </td></tr>
<tr class="separator:add6cb2d85282829eb9adc9565ce784d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad927d600371ba16dcb44518530ba906a"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:ad927d600371ba16dcb44518530ba906a"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad927d600371ba16dcb44518530ba906a">minCoeff</a> (IndexType *<a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row</a>, IndexType *<a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col</a>) const </td></tr>
<tr class="separator:ad927d600371ba16dcb44518530ba906a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae959fb7401b9cfdf900ff3b295466526"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:ae959fb7401b9cfdf900ff3b295466526"><td class="memTemplItemLeft" align="right" valign="top">internal::traits&lt; Derived &gt;::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae959fb7401b9cfdf900ff3b295466526">minCoeff</a> (IndexType *index) const </td></tr>
<tr class="separator:ae959fb7401b9cfdf900ff3b295466526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324b9263b40738a260d46ff011b8d31b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1NestByValue.html">NestByValue</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a324b9263b40738a260d46ff011b8d31b">nestByValue</a> () const </td></tr>
<tr class="separator:a324b9263b40738a260d46ff011b8d31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe29bfb5f2d88cf2a50ffb577ec6f0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abe29bfb5f2d88cf2a50ffb577ec6f0a4">nonZeros</a> () const </td></tr>
<tr class="separator:abe29bfb5f2d88cf2a50ffb577ec6f0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5648a35b9610ad47cb01912752db1dae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a5648a35b9610ad47cb01912752db1dae">operator!=</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a5648a35b9610ad47cb01912752db1dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ab11fb1ef0822aa61527f7ecd77b9d"><td class="memItemLeft" align="right" valign="top">const ScalarMultipleReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae8ab11fb1ef0822aa61527f7ecd77b9d">operator*</a> (const Scalar &amp;scalar) const</td></tr>
<tr class="separator:ae8ab11fb1ef0822aa61527f7ecd77b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a3dfc024abbb42150002facf498357"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_multiple2_op<br class="typebreak"/>
&lt; Scalar, std::complex&lt; Scalar &gt;<br class="typebreak"/>
 &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, <br class="typebreak"/>
_Rows, _Cols, _Options, <br class="typebreak"/>
_MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a01a3dfc024abbb42150002facf498357">operator*</a> (const std::complex&lt; Scalar &gt; &amp;scalar) const</td></tr>
<tr class="separator:a01a3dfc024abbb42150002facf498357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e1169b1338aa7edcc9a2dd69882ede"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_sum_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt;<br class="typebreak"/>
, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a32e1169b1338aa7edcc9a2dd69882ede">operator+</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a32e1169b1338aa7edcc9a2dd69882ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dab56059c2cd13fd3b36668a58fc1ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a><br class="typebreak"/>
&lt; internal::scalar_difference_op<br class="typebreak"/>
&lt; Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt;<br class="typebreak"/>
, const OtherDerived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a2dab56059c2cd13fd3b36668a58fc1ac">operator-</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a2dab56059c2cd13fd3b36668a58fc1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f53ae2f5586a75f1747d84822ae9581"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_opposite_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, <br class="typebreak"/>
_Cols, _Options, _MaxRows, <br class="typebreak"/>
_MaxCols &gt; &gt;::Scalar &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a7f53ae2f5586a75f1747d84822ae9581">operator-</a> () const</td></tr>
<tr class="separator:a7f53ae2f5586a75f1747d84822ae9581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78e46db7ee3ba78d3cf59968d261f90"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; internal::scalar_quotient1_op<br class="typebreak"/>
&lt; typename internal::traits<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, <br class="typebreak"/>
_Cols, _Options, _MaxRows, <br class="typebreak"/>
_MaxCols &gt; &gt;::Scalar &gt;, const <br class="typebreak"/>
<a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#ae78e46db7ee3ba78d3cf59968d261f90">operator/</a> (const Scalar &amp;scalar) const</td></tr>
<tr class="separator:ae78e46db7ee3ba78d3cf59968d261f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5d2e09de50c2ca145037f295542b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ade5d2e09de50c2ca145037f295542b16">operator&lt;&lt;</a> (const Scalar &amp;s)</td></tr>
<tr class="separator:ade5d2e09de50c2ca145037f295542b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dacded5374fe30f8d4eb4ae18bc87c9"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a3dacded5374fe30f8d4eb4ae18bc87c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3dacded5374fe30f8d4eb4ae18bc87c9">operator&lt;&lt;</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a3dacded5374fe30f8d4eb4ae18bc87c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cefab13f61a9dfd2733a7da70a264e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#ad0cefab13f61a9dfd2733a7da70a264e">operator=</a> (const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a> &amp;other)</td></tr>
<tr class="memdesc:ad0cefab13f61a9dfd2733a7da70a264e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns matrices to each other.  <a href="#ad0cefab13f61a9dfd2733a7da70a264e">More...</a><br/></td></tr>
<tr class="separator:ad0cefab13f61a9dfd2733a7da70a264e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cd84b304d3593c792fcd6fc1f3180f"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ae8cd84b304d3593c792fcd6fc1f3180f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Storage, _MaxRows, _MaxCols &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#ae8cd84b304d3593c792fcd6fc1f3180f">operator=</a> (const <a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a>&lt; OtherDerived, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a> &gt; &amp;r)</td></tr>
<tr class="memdesc:ae8cd84b304d3593c792fcd6fc1f3180f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a Dim x Dim rotation matrix from the rotation <em>r</em>.  <a href="#ae8cd84b304d3593c792fcd6fc1f3180f">More...</a><br/></td></tr>
<tr class="separator:ae8cd84b304d3593c792fcd6fc1f3180f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83f0a4a9e94b8ab5183aa9398e97539"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:af83f0a4a9e94b8ab5183aa9398e97539"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1Matrix.html#af83f0a4a9e94b8ab5183aa9398e97539">operator=</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:af83f0a4a9e94b8ab5183aa9398e97539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the generic expression <em>other</em> into *this.  <a href="#af83f0a4a9e94b8ab5183aa9398e97539">More...</a><br/></td></tr>
<tr class="separator:af83f0a4a9e94b8ab5183aa9398e97539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f22189db1a4cc4634bb8427ae64f06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a78f22189db1a4cc4634bb8427ae64f06">operator==</a> (const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other) const</td></tr>
<tr class="separator:a78f22189db1a4cc4634bb8427ae64f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af080d3d3f82e0d4391f19af22a5eedb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af080d3d3f82e0d4391f19af22a5eedb8">outerSize</a> () const </td></tr>
<tr class="separator:af080d3d3f82e0d4391f19af22a5eedb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdcbfa7e3b07d3246ad80de7170b0f5"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6bdcbfa7e3b07d3246ad80de7170b0f5">prod</a> () const </td></tr>
<tr class="separator:a6bdcbfa7e3b07d3246ad80de7170b0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1c87f8e48a66edc05859421048f8b0"><td class="memItemLeft" align="right" valign="top">RealReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a4a1c87f8e48a66edc05859421048f8b0">real</a> () const</td></tr>
<tr class="separator:a4a1c87f8e48a66edc05859421048f8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfa15407b80807dab914b1844c725e5"><td class="memItemLeft" align="right" valign="top">NonConstRealReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#accfa15407b80807dab914b1844c725e5">real</a> ()</td></tr>
<tr class="separator:accfa15407b80807dab914b1844c725e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64248a8479a46b78fa5b19702aa5d212"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a64248a8479a46b78fa5b19702aa5d212"><td class="memTemplItemLeft" align="right" valign="top">internal::result_of&lt; Func(typename <br class="typebreak"/>
internal::traits&lt; Derived &gt;<br class="typebreak"/>
::Scalar)&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a64248a8479a46b78fa5b19702aa5d212">redux</a> (const Func &amp;func) const </td></tr>
<tr class="separator:a64248a8479a46b78fa5b19702aa5d212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca0e8ff7921ee0e3ab4422818ecb214"><td class="memTemplParams" colspan="2">template&lt;int RowFactor, int ColFactor&gt; </td></tr>
<tr class="memitem:afca0e8ff7921ee0e3ab4422818ecb214"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, <br class="typebreak"/>
RowFactor, ColFactor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afca0e8ff7921ee0e3ab4422818ecb214">replicate</a> () const </td></tr>
<tr class="separator:afca0e8ff7921ee0e3ab4422818ecb214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2cad18a5459a6c98563defff4e3d0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Replicate.html">ReplicateReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0d2cad18a5459a6c98563defff4e3d0f">replicate</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rowFacor, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> colFactor) const </td></tr>
<tr class="separator:a0d2cad18a5459a6c98563defff4e3d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbb33d14fe7fb9683019a39ce1c659d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#afbbb33d14fe7fb9683019a39ce1c659d">resize</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> nbRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> nbCols)</td></tr>
<tr class="separator:afbbb33d14fe7fb9683019a39ce1c659d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8db206b78137e95dc0833952ed1ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#a0b8db206b78137e95dc0833952ed1ed0">resize</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="separator:a0b8db206b78137e95dc0833952ed1ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9ca3c51c341a06bce3451ff1adc84d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#aec9ca3c51c341a06bce3451ff1adc84d">resize</a> (NoChange_t, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> nbCols)</td></tr>
<tr class="separator:aec9ca3c51c341a06bce3451ff1adc84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d9d13dd3982d05458767072c257886"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#a58d9d13dd3982d05458767072c257886">resize</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> nbRows, NoChange_t)</td></tr>
<tr class="separator:a58d9d13dd3982d05458767072c257886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7b7417203825a6e434449cf0ac6529"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#abe7b7417203825a6e434449cf0ac6529">resizeLike</a> (const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;_other)</td></tr>
<tr class="separator:abe7b7417203825a6e434449cf0ac6529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e354bb81f0c7b6888c6a0ce4b4649e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6e354bb81f0c7b6888c6a0ce4b4649e2">reverse</a> ()</td></tr>
<tr class="separator:a6e354bb81f0c7b6888c6a0ce4b4649e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a4b984747fa12de0f521b3bff907b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae3a4b984747fa12de0f521b3bff907b3">reverse</a> () const </td></tr>
<tr class="separator:ae3a4b984747fa12de0f521b3bff907b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af148c4e77e657d04573c4fda43740ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af148c4e77e657d04573c4fda43740ed5">reverseInPlace</a> ()</td></tr>
<tr class="separator:af148c4e77e657d04573c4fda43740ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80f9e4e3708d7e3b0e1487ca90cf339"><td class="memItemLeft" align="right" valign="top">ColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af80f9e4e3708d7e3b0e1487ca90cf339">rightCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="separator:af80f9e4e3708d7e3b0e1487ca90cf339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16081d19c5482a30aa6be15769e8056"><td class="memItemLeft" align="right" valign="top">ConstColsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad16081d19c5482a30aa6be15769e8056">rightCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const </td></tr>
<tr class="separator:ad16081d19c5482a30aa6be15769e8056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3400066e9b6d285f5214748b6332a7a4"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a3400066e9b6d285f5214748b6332a7a4"><td class="memTemplItemLeft" align="right" valign="top">NColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3400066e9b6d285f5214748b6332a7a4">rightCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N)</td></tr>
<tr class="separator:a3400066e9b6d285f5214748b6332a7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553136b326ce6bdd67ff4610ea20f598"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a553136b326ce6bdd67ff4610ea20f598"><td class="memTemplItemLeft" align="right" valign="top">ConstNColsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a553136b326ce6bdd67ff4610ea20f598">rightCols</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N) const </td></tr>
<tr class="separator:a553136b326ce6bdd67ff4610ea20f598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8716d44f51321072ee5c88665c28813"><td class="memItemLeft" align="right" valign="top">RowXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i)</td></tr>
<tr class="separator:aa8716d44f51321072ee5c88665c28813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62dcaf648cca25e9318da34c9840799"><td class="memItemLeft" align="right" valign="top">ConstRowXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad62dcaf648cca25e9318da34c9840799">row</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i) const </td></tr>
<tr class="separator:ad62dcaf648cca25e9318da34c9840799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af2f03b1d2affcec24e0748edf892cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">ConstRowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3af2f03b1d2affcec24e0748edf892cd">rowwise</a> () const </td></tr>
<tr class="separator:a3af2f03b1d2affcec24e0748edf892cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7fd1e8004d4bd93a7ea36957aa8e99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1VectorwiseOp.html">RowwiseReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8a7fd1e8004d4bd93a7ea36957aa8e99">rowwise</a> ()</td></tr>
<tr class="separator:a8a7fd1e8004d4bd93a7ea36957aa8e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfa43e5ac3984e38b1dee1f06415003"><td class="memItemLeft" align="right" valign="top">SegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9dfa43e5ac3984e38b1dee1f06415003">segment</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> start, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="separator:a9dfa43e5ac3984e38b1dee1f06415003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686a182050df26084c0519f9f6633c68"><td class="memItemLeft" align="right" valign="top">ConstSegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a686a182050df26084c0519f9f6633c68">segment</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> start, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const </td></tr>
<tr class="separator:a686a182050df26084c0519f9f6633c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57815573b5eeac29e8d12d6136dd05fd"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a57815573b5eeac29e8d12d6136dd05fd"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a57815573b5eeac29e8d12d6136dd05fd">segment</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> start, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N)</td></tr>
<tr class="separator:a57815573b5eeac29e8d12d6136dd05fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4183a7b0211a36ddf2081db7aa4376"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a8f4183a7b0211a36ddf2081db7aa4376"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType&lt; N &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8f4183a7b0211a36ddf2081db7aa4376">segment</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> start, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N) const </td></tr>
<tr class="separator:a8f4183a7b0211a36ddf2081db7aa4376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaed9ab0c7a20c689017542e40d1ef6e"><td class="memTemplParams" colspan="2">template&lt;typename ThenDerived , typename ElseDerived &gt; </td></tr>
<tr class="memitem:aaaed9ab0c7a20c689017542e40d1ef6e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, <br class="typebreak"/>
ThenDerived, ElseDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aaaed9ab0c7a20c689017542e40d1ef6e">select</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const </td></tr>
<tr class="separator:aaaed9ab0c7a20c689017542e40d1ef6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59df26fd07b401c361f53d84642d73ed"><td class="memTemplParams" colspan="2">template&lt;typename ThenDerived &gt; </td></tr>
<tr class="memitem:a59df26fd07b401c361f53d84642d73ed"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, <br class="typebreak"/>
ThenDerived, typename <br class="typebreak"/>
ThenDerived::ConstantReturnType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a59df26fd07b401c361f53d84642d73ed">select</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;thenMatrix, const typename ThenDerived::Scalar &amp;elseScalar) const </td></tr>
<tr class="separator:a59df26fd07b401c361f53d84642d73ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc67de2ba1403e6856bd1b7dd1388f9"><td class="memTemplParams" colspan="2">template&lt;typename ElseDerived &gt; </td></tr>
<tr class="memitem:adfc67de2ba1403e6856bd1b7dd1388f9"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, <br class="typebreak"/>
typename <br class="typebreak"/>
ElseDerived::ConstantReturnType, <br class="typebreak"/>
ElseDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adfc67de2ba1403e6856bd1b7dd1388f9">select</a> (const typename ElseDerived::Scalar &amp;thenScalar, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;elseMatrix) const </td></tr>
<tr class="separator:adfc67de2ba1403e6856bd1b7dd1388f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351ca566980cf96d9cdd61f3ce0cf94f"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a351ca566980cf96d9cdd61f3ce0cf94f">setConstant</a> (const Scalar &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>)</td></tr>
<tr class="separator:a351ca566980cf96d9cdd61f3ce0cf94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca96b3050ceeffaa781d3d4ee185bd1d"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aca96b3050ceeffaa781d3d4ee185bd1d">setLinSpaced</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="memdesc:aca96b3050ceeffaa781d3d4ee185bd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly space vector.  <a href="#aca96b3050ceeffaa781d3d4ee185bd1d">More...</a><br/></td></tr>
<tr class="separator:aca96b3050ceeffaa781d3d4ee185bd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043485fa5a9510639cd8034392371aec"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a043485fa5a9510639cd8034392371aec">setLinSpaced</a> (const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="memdesc:a043485fa5a9510639cd8034392371aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly space vector.  <a href="#a043485fa5a9510639cd8034392371aec">More...</a><br/></td></tr>
<tr class="separator:a043485fa5a9510639cd8034392371aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196e62ee8a1fc3b4af631e955d650cfc"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a196e62ee8a1fc3b4af631e955d650cfc">setOnes</a> ()</td></tr>
<tr class="separator:a196e62ee8a1fc3b4af631e955d650cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab795c242db18862f502dfd9fa625c504"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ab795c242db18862f502dfd9fa625c504">setRandom</a> ()</td></tr>
<tr class="separator:ab795c242db18862f502dfd9fa625c504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9053ca03ac251002768a54742be28fce"><td class="memItemLeft" align="right" valign="top">Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a> ()</td></tr>
<tr class="separator:a9053ca03ac251002768a54742be28fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3b3fb530d3364ecef0bf9c9daf0983"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3a3b3fb530d3364ecef0bf9c9daf0983">sum</a> () const </td></tr>
<tr class="separator:a3a3b3fb530d3364ecef0bf9c9daf0983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3bfb296c2f8e29aac6037b16c2e8a9"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:add3bfb296c2f8e29aac6037b16c2e8a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#add3bfb296c2f8e29aac6037b16c2e8a9">swap</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other, int=OtherDerived::ThisConstantIsPrivateInPlainObjectBase)</td></tr>
<tr class="separator:add3bfb296c2f8e29aac6037b16c2e8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203951fa04396e45d2c38737943c2c55"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a203951fa04396e45d2c38737943c2c55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a203951fa04396e45d2c38737943c2c55">swap</a> (<a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a203951fa04396e45d2c38737943c2c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bed656b21b610ae88c51d281b5f8c44"><td class="memItemLeft" align="right" valign="top">SegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3bed656b21b610ae88c51d281b5f8c44">tail</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="separator:a3bed656b21b610ae88c51d281b5f8c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e993c3ec78be489101773aa809ea52e"><td class="memItemLeft" align="right" valign="top">ConstSegmentReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a5e993c3ec78be489101773aa809ea52e">tail</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const </td></tr>
<tr class="separator:a5e993c3ec78be489101773aa809ea52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392a82a3f895ed885a654ebaaffcf47f"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a392a82a3f895ed885a654ebaaffcf47f"><td class="memTemplItemLeft" align="right" valign="top">FixedSegmentReturnType&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a392a82a3f895ed885a654ebaaffcf47f">tail</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N)</td></tr>
<tr class="separator:a392a82a3f895ed885a654ebaaffcf47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256bdc19a7d6b5d9cb16cb683b446e6d"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a256bdc19a7d6b5d9cb16cb683b446e6d"><td class="memTemplItemLeft" align="right" valign="top">ConstFixedSegmentReturnType&lt; N &gt;<br class="typebreak"/>
::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a256bdc19a7d6b5d9cb16cb683b446e6d">tail</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N) const </td></tr>
<tr class="separator:a256bdc19a7d6b5d9cb16cb683b446e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5fc5fe9d3fb70e62d4a9b1795704a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6f5fc5fe9d3fb70e62d4a9b1795704a8">topLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="separator:a6f5fc5fe9d3fb70e62d4a9b1795704a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51f8dd1a464c0fe48182f7bab7ffab6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af51f8dd1a464c0fe48182f7bab7ffab6">topLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const </td></tr>
<tr class="separator:af51f8dd1a464c0fe48182f7bab7ffab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06d0a5c4008014fb717866aec8d30c7"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:ae06d0a5c4008014fb717866aec8d30c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae06d0a5c4008014fb717866aec8d30c7">topLeftCorner</a> ()</td></tr>
<tr class="separator:ae06d0a5c4008014fb717866aec8d30c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c05f280e61cf18f5865b0065cc769a"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a29c05f280e61cf18f5865b0065cc769a"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a29c05f280e61cf18f5865b0065cc769a">topLeftCorner</a> () const </td></tr>
<tr class="separator:a29c05f280e61cf18f5865b0065cc769a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2942bfb77ac330fdd91d3f063686a63"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:ae2942bfb77ac330fdd91d3f063686a63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae2942bfb77ac330fdd91d3f063686a63">topLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="separator:ae2942bfb77ac330fdd91d3f063686a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b549d0127afc14bab07e4f440c4aeec"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a0b549d0127afc14bab07e4f440c4aeec"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a0b549d0127afc14bab07e4f440c4aeec">topLeftCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const </td></tr>
<tr class="separator:a0b549d0127afc14bab07e4f440c4aeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318006038c9becc5f9af003b7c77ea18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a318006038c9becc5f9af003b7c77ea18">topRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="separator:a318006038c9becc5f9af003b7c77ea18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd6c56ce974c092a0aa0f11ca1853cb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8cd6c56ce974c092a0aa0f11ca1853cb">topRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const </td></tr>
<tr class="separator:a8cd6c56ce974c092a0aa0f11ca1853cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0088b2c1ec4dbd677dd19f589777945"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:ad0088b2c1ec4dbd677dd19f589777945"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad0088b2c1ec4dbd677dd19f589777945">topRightCorner</a> ()</td></tr>
<tr class="separator:ad0088b2c1ec4dbd677dd19f589777945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe4b3135cc0afa4eee8d9db60c637c1"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:abbe4b3135cc0afa4eee8d9db60c637c1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abbe4b3135cc0afa4eee8d9db60c637c1">topRightCorner</a> () const </td></tr>
<tr class="separator:abbe4b3135cc0afa4eee8d9db60c637c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd671d8eea4781a3808d59718ba8b42"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a1bd671d8eea4781a3808d59718ba8b42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt; Derived, CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a1bd671d8eea4781a3808d59718ba8b42">topRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols)</td></tr>
<tr class="separator:a1bd671d8eea4781a3808d59718ba8b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df165d3b3bedfe1386f20f3c2126973"><td class="memTemplParams" colspan="2">template&lt;int CRows, int CCols&gt; </td></tr>
<tr class="memitem:a8df165d3b3bedfe1386f20f3c2126973"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt; const Derived, <br class="typebreak"/>
CRows, CCols &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8df165d3b3bedfe1386f20f3c2126973">topRightCorner</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cRows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cCols) const </td></tr>
<tr class="separator:a8df165d3b3bedfe1386f20f3c2126973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfced3e157f74b3bc68892aad178424"><td class="memItemLeft" align="right" valign="top">RowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#afdfced3e157f74b3bc68892aad178424">topRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n)</td></tr>
<tr class="separator:afdfced3e157f74b3bc68892aad178424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77be6c2cf44abbb6f80496cbe14f2af"><td class="memItemLeft" align="right" valign="top">ConstRowsBlockXpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac77be6c2cf44abbb6f80496cbe14f2af">topRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n) const </td></tr>
<tr class="separator:ac77be6c2cf44abbb6f80496cbe14f2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5159cea1bb46677c35df0dc06237a6"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a7e5159cea1bb46677c35df0dc06237a6"><td class="memTemplItemLeft" align="right" valign="top">NRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a7e5159cea1bb46677c35df0dc06237a6">topRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N)</td></tr>
<tr class="separator:a7e5159cea1bb46677c35df0dc06237a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4cd92f386a6d4a583eac2a7637cc07"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a9c4cd92f386a6d4a583eac2a7637cc07"><td class="memTemplItemLeft" align="right" valign="top">ConstNRowsBlockXpr&lt; N &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a9c4cd92f386a6d4a583eac2a7637cc07">topRows</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> n=N) const </td></tr>
<tr class="separator:a9c4cd92f386a6d4a583eac2a7637cc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c187c30922fc5e42f208ae3eb0970ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Transpose.html">Eigen::Transpose</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose</a> ()</td></tr>
<tr class="separator:a3c187c30922fc5e42f208ae3eb0970ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228b8f9641f46db6e92e06374ea87918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Transpose.html">ConstTransposeReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a228b8f9641f46db6e92e06374ea87918">transpose</a> () const </td></tr>
<tr class="separator:a228b8f9641f46db6e92e06374ea87918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3689faf485a5e405a4fc9bf0e05564c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3689faf485a5e405a4fc9bf0e05564c9">transposeInPlace</a> ()</td></tr>
<tr class="separator:a3689faf485a5e405a4fc9bf0e05564c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fc4bf97168dee2516f85edcfd4cfe7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a><br class="typebreak"/>
&lt; CustomUnaryOp, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#a23fc4bf97168dee2516f85edcfd4cfe7">unaryExpr</a> (const CustomUnaryOp &amp;func=CustomUnaryOp()) const</td></tr>
<tr class="memdesc:a23fc4bf97168dee2516f85edcfd4cfe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a unary operator coefficient-wise.  <a href="#a23fc4bf97168dee2516f85edcfd4cfe7">More...</a><br/></td></tr>
<tr class="separator:a23fc4bf97168dee2516f85edcfd4cfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9ae3923f6caa962ef3418d6872c369"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a><br class="typebreak"/>
&lt; CustomViewOp, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a><br class="typebreak"/>
&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixBase.html#aba9ae3923f6caa962ef3418d6872c369">unaryViewExpr</a> (const CustomViewOp &amp;func=CustomViewOp()) const</td></tr>
<tr class="separator:aba9ae3923f6caa962ef3418d6872c369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf21a576b8f3a10bb141b8afd173b13d"><td class="memItemLeft" align="right" valign="top">CoeffReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a> () const </td></tr>
<tr class="separator:adf21a576b8f3a10bb141b8afd173b13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33f695c0e0ad5634ca73f19c347f7b3"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:af33f695c0e0ad5634ca73f19c347f7b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#af33f695c0e0ad5634ca73f19c347f7b3">visit</a> (Visitor &amp;func) const </td></tr>
<tr class="separator:af33f695c0e0ad5634ca73f19c347f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abb7652b9ae2c6ee26be9db276613c4f6"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#abb7652b9ae2c6ee26be9db276613c4f6">Constant</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols, const Scalar &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>)</td></tr>
<tr class="separator:abb7652b9ae2c6ee26be9db276613c4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07edf1aa85b7e84bd6b15158efbca71"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa07edf1aa85b7e84bd6b15158efbca71">Constant</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const Scalar &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>)</td></tr>
<tr class="separator:aa07edf1aa85b7e84bd6b15158efbca71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3647a2091ca73b864aee4126118fd44"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#aa3647a2091ca73b864aee4126118fd44">Constant</a> (const Scalar &amp;<a class="el" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>)</td></tr>
<tr class="separator:aa3647a2091ca73b864aee4126118fd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a4ddf48fc9f3674a783da9c6ae34d8"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
SequentialLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">LinSpaced</a> (Sequential_t, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="memdesc:a03a4ddf48fc9f3674a783da9c6ae34d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly space vector.  <a href="#a03a4ddf48fc9f3674a783da9c6ae34d8">More...</a><br/></td></tr>
<tr class="separator:a03a4ddf48fc9f3674a783da9c6ae34d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3a25508eab3a05851a3b4208b96eb8"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
RandomAccessLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#add3a25508eab3a05851a3b4208b96eb8">LinSpaced</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="memdesc:add3a25508eab3a05851a3b4208b96eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly space vector.  <a href="#add3a25508eab3a05851a3b4208b96eb8">More...</a><br/></td></tr>
<tr class="separator:add3a25508eab3a05851a3b4208b96eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ceb9d76f8ca3ff5bc71f7797b9788d"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
SequentialLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a30ceb9d76f8ca3ff5bc71f7797b9788d">LinSpaced</a> (Sequential_t, const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="memdesc:a30ceb9d76f8ca3ff5bc71f7797b9788d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly space vector.  <a href="#a30ceb9d76f8ca3ff5bc71f7797b9788d">More...</a><br/></td></tr>
<tr class="separator:a30ceb9d76f8ca3ff5bc71f7797b9788d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e2ccb6cded6a7aa927c3410aee071b"><td class="memItemLeft" align="right" valign="top">static const <br class="typebreak"/>
RandomAccessLinSpacedReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ac0e2ccb6cded6a7aa927c3410aee071b">LinSpaced</a> (const Scalar &amp;low, const Scalar &amp;high)</td></tr>
<tr class="memdesc:ac0e2ccb6cded6a7aa927c3410aee071b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a linearly space vector.  <a href="#ac0e2ccb6cded6a7aa927c3410aee071b">More...</a><br/></td></tr>
<tr class="separator:ac0e2ccb6cded6a7aa927c3410aee071b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138e37f3c338a544afb347aaf80d32da"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a138e37f3c338a544afb347aaf80d32da"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; CustomNullaryOp, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">NullaryExpr</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols, const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a138e37f3c338a544afb347aaf80d32da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50fd894930b4f917cf5c40f23965f67"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:ae50fd894930b4f917cf5c40f23965f67"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; CustomNullaryOp, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ae50fd894930b4f917cf5c40f23965f67">NullaryExpr</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:ae50fd894930b4f917cf5c40f23965f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24025debf13d8352eb963b814e08b5e8"><td class="memTemplParams" colspan="2">template&lt;typename CustomNullaryOp &gt; </td></tr>
<tr class="memitem:a24025debf13d8352eb963b814e08b5e8"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; CustomNullaryOp, Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a24025debf13d8352eb963b814e08b5e8">NullaryExpr</a> (const CustomNullaryOp &amp;func)</td></tr>
<tr class="separator:a24025debf13d8352eb963b814e08b5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad148f93a6a00e32ef00903c5393337ef"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#ad148f93a6a00e32ef00903c5393337ef">Ones</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols)</td></tr>
<tr class="separator:ad148f93a6a00e32ef00903c5393337ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec530c086d6b585ebb009fe4fbb77e6"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#adec530c086d6b585ebb009fe4fbb77e6">Ones</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="separator:adec530c086d6b585ebb009fe4fbb77e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2278addf9a3c977d40322571a0df8ac9"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Ones</a> ()</td></tr>
<tr class="separator:a2278addf9a3c977d40322571a0df8ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78061942c4ccb57f5b1dde173fdd8bd0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; internal::scalar_random_op<br class="typebreak"/>
&lt; Scalar &gt;, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a78061942c4ccb57f5b1dde173fdd8bd0">Random</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols)</td></tr>
<tr class="separator:a78061942c4ccb57f5b1dde173fdd8bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f42aba8fbe2618deb0e80e4af876e04"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; internal::scalar_random_op<br class="typebreak"/>
&lt; Scalar &gt;, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a6f42aba8fbe2618deb0e80e4af876e04">Random</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="separator:a6f42aba8fbe2618deb0e80e4af876e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e759dafdd9ecc446d397b7f5435f60a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a><br class="typebreak"/>
&lt; internal::scalar_random_op<br class="typebreak"/>
&lt; Scalar &gt;, Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Random</a> ()</td></tr>
<tr class="separator:a8e759dafdd9ecc446d397b7f5435f60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724349af3e253b69a54d503931b52ec3"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a724349af3e253b69a54d503931b52ec3">Zero</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols)</td></tr>
<tr class="separator:a724349af3e253b69a54d503931b52ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39390955f1297dacb49ac94429f321fd"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a39390955f1297dacb49ac94429f321fd">Zero</a> (<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="separator:a39390955f1297dacb49ac94429f321fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e36721b4833498b713e94a7948c6a29"><td class="memItemLeft" align="right" valign="top">static const ConstantReturnType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero</a> ()</td></tr>
<tr class="separator:a2e36721b4833498b713e94a7948c6a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Map</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are convenience functions returning <a class="el" href="classEigen_1_1Map.html" title="A matrix or vector expression mapping an existing array of data. ">Map</a> objects. The Map() static functions return unaligned <a class="el" href="classEigen_1_1Map.html" title="A matrix or vector expression mapping an existing array of data. ">Map</a> objects, while the AlignedMap() functions return aligned <a class="el" href="classEigen_1_1Map.html" title="A matrix or vector expression mapping an existing array of data. ">Map</a> objects and thus should be called only with 16-byte-aligned <em>data</em> pointers.</p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Map.html" title="A matrix or vector expression mapping an existing array of data. ">Map</a> </dd></dl>
</div></td></tr>
<tr class="memitem:ac52c575853da7de243d1142a35349e96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac52c575853da7de243d1142a35349e96"></a>
static <a class="el" href="classEigen_1_1Map.html">ConstMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>)</td></tr>
<tr class="separator:ac52c575853da7de243d1142a35349e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffd15e8174a79a69a2b85fb36766748"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ffd15e8174a79a69a2b85fb36766748"></a>
static <a class="el" href="classEigen_1_1Map.html">MapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>)</td></tr>
<tr class="separator:a6ffd15e8174a79a69a2b85fb36766748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1660531fc88568a5defdb00224415e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1660531fc88568a5defdb00224415e5"></a>
static <a class="el" href="classEigen_1_1Map.html">ConstMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="separator:ad1660531fc88568a5defdb00224415e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fde2114110ce2e1dea247ca7ea4ec80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fde2114110ce2e1dea247ca7ea4ec80"></a>
static <a class="el" href="classEigen_1_1Map.html">MapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="separator:a7fde2114110ce2e1dea247ca7ea4ec80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2f0645c710c69d2867330ad52e3eb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d2f0645c710c69d2867330ad52e3eb4"></a>
static <a class="el" href="classEigen_1_1Map.html">ConstMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols)</td></tr>
<tr class="separator:a6d2f0645c710c69d2867330ad52e3eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe74b89d21566bcafff0a785d29aa9ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe74b89d21566bcafff0a785d29aa9ec"></a>
static <a class="el" href="classEigen_1_1Map.html">MapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols)</td></tr>
<tr class="separator:afe74b89d21566bcafff0a785d29aa9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc12d3da3334f074ef78ce4574c02b1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc12d3da3334f074ef78ce4574c02b1e"></a>
static StridedConstMapType<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:afc12d3da3334f074ef78ce4574c02b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e1507113597a170c6da1f5160f4e6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62e1507113597a170c6da1f5160f4e6e"></a>
static StridedMapType&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a><br class="typebreak"/>
&lt; Outer, Inner &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:a62e1507113597a170c6da1f5160f4e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42b8fbe1ec1c53f7be0c87ff642b930"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af42b8fbe1ec1c53f7be0c87ff642b930"></a>
static StridedConstMapType<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:af42b8fbe1ec1c53f7be0c87ff642b930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad288d654300a85d77774538cabf0883c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad288d654300a85d77774538cabf0883c"></a>
static StridedMapType&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a><br class="typebreak"/>
&lt; Outer, Inner &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:ad288d654300a85d77774538cabf0883c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068773dba022bcc362ca5ef41d10e5e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a068773dba022bcc362ca5ef41d10e5e3"></a>
static StridedConstMapType<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:a068773dba022bcc362ca5ef41d10e5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7584fd4fbe3e3d5f2d24ff381955fbf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7584fd4fbe3e3d5f2d24ff381955fbf8"></a>
static StridedMapType&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a><br class="typebreak"/>
&lt; Outer, Inner &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:a7584fd4fbe3e3d5f2d24ff381955fbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dac2e03da821c7e7342d94280c8b423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dac2e03da821c7e7342d94280c8b423"></a>
static <a class="el" href="classEigen_1_1Map.html">ConstAlignedMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>)</td></tr>
<tr class="separator:a8dac2e03da821c7e7342d94280c8b423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4c8353053c367b476f29293c45519c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a4c8353053c367b476f29293c45519c"></a>
static <a class="el" href="classEigen_1_1Map.html">AlignedMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>)</td></tr>
<tr class="separator:a8a4c8353053c367b476f29293c45519c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5021a7d90793fec34552875251568d9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5021a7d90793fec34552875251568d9d"></a>
static <a class="el" href="classEigen_1_1Map.html">ConstAlignedMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="separator:a5021a7d90793fec34552875251568d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf57b80587a641c17b7359b2c72250b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf57b80587a641c17b7359b2c72250b"></a>
static <a class="el" href="classEigen_1_1Map.html">AlignedMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size)</td></tr>
<tr class="separator:aecf57b80587a641c17b7359b2c72250b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad010f9df8245dadc5a19c02be6d7bcf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad010f9df8245dadc5a19c02be6d7bcf8"></a>
static <a class="el" href="classEigen_1_1Map.html">ConstAlignedMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols)</td></tr>
<tr class="separator:ad010f9df8245dadc5a19c02be6d7bcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a6bbf40be3ee18223fd59db789350c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63a6bbf40be3ee18223fd59db789350c"></a>
static <a class="el" href="classEigen_1_1Map.html">AlignedMapType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols)</td></tr>
<tr class="separator:a63a6bbf40be3ee18223fd59db789350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b9ecc0dd231c7a5eccc3963511d4ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62b9ecc0dd231c7a5eccc3963511d4ec"></a>
static <br class="typebreak"/>
StridedConstAlignedMapType<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:a62b9ecc0dd231c7a5eccc3963511d4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7a2af56aad9706af5b930732b2be2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc7a2af56aad9706af5b930732b2be2e"></a>
static StridedAlignedMapType<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:adc7a2af56aad9706af5b930732b2be2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b75e75f67b55b84a6c62e2d4577ff6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7b75e75f67b55b84a6c62e2d4577ff6"></a>
static <br class="typebreak"/>
StridedConstAlignedMapType<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:ae7b75e75f67b55b84a6c62e2d4577ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bfa83224478c85a37ddd962c3d844d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2bfa83224478c85a37ddd962c3d844d"></a>
static StridedAlignedMapType<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> size, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:af2bfa83224478c85a37ddd962c3d844d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8c3ef5aef0d73923826d00984e3675"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f8c3ef5aef0d73923826d00984e3675"></a>
static <br class="typebreak"/>
StridedConstAlignedMapType<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (const Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:a3f8c3ef5aef0d73923826d00984e3675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3e6d1b9633c1d4a7a74be8903e6334"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb3e6d1b9633c1d4a7a74be8903e6334"></a>
static StridedAlignedMapType<br class="typebreak"/>
&lt; <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt;<br class="typebreak"/>
 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>MapAligned</b> (Scalar *<a class="el" href="classEigen_1_1PlainObjectBase.html#a40dcc334db75411e168691d9bce08c3a">data</a>, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> rows, <a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> cols, const <a class="el" href="classEigen_1_1Stride.html">Stride</a>&lt; Outer, Inner &gt; &amp;stride)</td></tr>
<tr class="separator:acb3e6d1b9633c1d4a7a74be8903e6334"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3cbc7e8bccd9a8736af1a9968dec74d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, <br class="typebreak"/>
_Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PlainObjectBase.html#a3cbc7e8bccd9a8736af1a9968dec74d9">_set</a> (const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a3cbc7e8bccd9a8736af1a9968dec74d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the value of the expression <em>other</em> into <code>*this</code> with automatic resizing.  <a href="#a3cbc7e8bccd9a8736af1a9968dec74d9">More...</a><br/></td></tr>
<tr class="separator:a3cbc7e8bccd9a8736af1a9968dec74d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a3806d3f42de165878dace160e6aba40a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3806d3f42de165878dace160e6aba40a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEigen_1_1DenseBase.html#a3806d3f42de165878dace160e6aba40a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt; &amp;m)</td></tr>
<tr class="separator:a3806d3f42de165878dace160e6aba40a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a319e79809d439b8fabeafa27c28c8835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt;<a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&gt; Base</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base class typedef. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1PlainObjectBase.html" title="Dense storage base class for matrices and arrays. ">PlainObjectBase</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6ea38ab482a62bf46f6ed6dcc4e9dd0dddf"></a>RowsAtCompileTime</em>&nbsp;</td><td class="fielddoc">
<p>The number of rows at compile-time. This is just a copy of the value provided by the <em>Derived</em> type. If a value is not known at compile-time, it is set to the <em>Dynamic</em> constant. </p>
<dl class="section see"><dt>See Also</dt><dd>MatrixBase::rows(), MatrixBase::cols(), <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a>, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eab30be5c02d7a124ec165d2ab6c5b05ed">SizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6eae943bdba893721a848dfcd03db756b22"></a>ColsAtCompileTime</em>&nbsp;</td><td class="fielddoc">
<p>The number of columns at compile-time. This is just a copy of the value provided by the <em>Derived</em> type. If a value is not known at compile-time, it is set to the <em>Dynamic</em> constant. </p>
<dl class="section see"><dt>See Also</dt><dd>MatrixBase::rows(), MatrixBase::cols(), <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea38ab482a62bf46f6ed6dcc4e9dd0dddf">RowsAtCompileTime</a>, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eab30be5c02d7a124ec165d2ab6c5b05ed">SizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6eab30be5c02d7a124ec165d2ab6c5b05ed"></a>SizeAtCompileTime</em>&nbsp;</td><td class="fielddoc">
<p>This is equal to the number of coefficients, i.e. the number of rows times the number of columns, or to <em>Dynamic</em> if this is not known at compile-time. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea38ab482a62bf46f6ed6dcc4e9dd0dddf">RowsAtCompileTime</a>, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6ea1264a9a69c437cbe0f8e723d88471c4a"></a>MaxRowsAtCompileTime</em>&nbsp;</td><td class="fielddoc">
<p>This value is equal to the maximum possible number of rows that this expression might have. If this expression might have an arbitrarily high number of rows, this value is set to <em>Dynamic</em>.</p>
<p>This value is useful to know when evaluating an expression, in order to determine whether it is possible to avoid doing a dynamic memory allocation.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea38ab482a62bf46f6ed6dcc4e9dd0dddf">RowsAtCompileTime</a>, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eac9998fd25639e32ba4d58d67bfff4420">MaxColsAtCompileTime</a>, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eacf4ecb7db5a851c1ff90ae7621ab3fd1">MaxSizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6eac9998fd25639e32ba4d58d67bfff4420"></a>MaxColsAtCompileTime</em>&nbsp;</td><td class="fielddoc">
<p>This value is equal to the maximum possible number of columns that this expression might have. If this expression might have an arbitrarily high number of columns, this value is set to <em>Dynamic</em>.</p>
<p>This value is useful to know when evaluating an expression, in order to determine whether it is possible to avoid doing a dynamic memory allocation.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a>, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea1264a9a69c437cbe0f8e723d88471c4a">MaxRowsAtCompileTime</a>, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eacf4ecb7db5a851c1ff90ae7621ab3fd1">MaxSizeAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6eacf4ecb7db5a851c1ff90ae7621ab3fd1"></a>MaxSizeAtCompileTime</em>&nbsp;</td><td class="fielddoc">
<p>This value is equal to the maximum possible number of coefficients that this expression might have. If this expression might have an arbitrarily high number of coefficients, this value is set to <em>Dynamic</em>.</p>
<p>This value is useful to know when evaluating an expression, in order to determine whether it is possible to avoid doing a dynamic memory allocation.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eab30be5c02d7a124ec165d2ab6c5b05ed">SizeAtCompileTime</a>, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea1264a9a69c437cbe0f8e723d88471c4a">MaxRowsAtCompileTime</a>, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eac9998fd25639e32ba4d58d67bfff4420">MaxColsAtCompileTime</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6ea7e22277c8f0a1a76dd0d6c62e366b59f"></a>IsVectorAtCompileTime</em>&nbsp;</td><td class="fielddoc">
<p>This is set to true if either the number of rows or the number of columns is known at compile-time to be equal to 1. Indeed, in that case, we are dealing with a column-vector (if there is only one column) or with a row-vector (if there is only one row). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6ea96296863b401484bc191339414c90e6b"></a>Flags</em>&nbsp;</td><td class="fielddoc">
<p>This stores expression <a class="el" href="group__flags.html">Flags</a> flags which may or may not be inherited by new expressions constructed from this one. See the <a class="el" href="group__flags.html">list of flags</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6ea247b0f8b0eb0bfd5e253eb1e4b61436b"></a>IsRowMajor</em>&nbsp;</td><td class="fielddoc">
<p>True if this expression has row-major storage order. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="afa9be5679ab03d785820f2474c5ccc6ea17c43b803133ba4f73b417edcbfb8206"></a>CoeffReadCost</em>&nbsp;</td><td class="fielddoc">
<p>This is a rough measure of how expensive it is to read one coefficient from this expression. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3aede62f513da27e6f61ae7a972b4f96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>For fixed-size matrices, does nothing.</p>
<p>For dynamic-size matrices, creates an empty matrix of size 0. Does not allocate any array. Such a matrix is called a null matrix. This constructor is the unique way to create null matrices: resizing a matrix to 0 is not supported.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1PlainObjectBase.html#afbbb33d14fe7fb9683019a39ce1c659d">resize(Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3727f1c83c30f0b5a0056d7aaa077c4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a vector or row-vector with given dimension. This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column. </p>
<p>Note that this is only useful for dynamic-size vectors. For fixed-size vectors, it is redundant to pass the dimension here, so it makes more sense to use the default constructor <a class="el" href="classEigen_1_1Matrix.html#a3aede62f513da27e6f61ae7a972b4f96" title="Default constructor. ">Matrix()</a> instead. </p>

</div>
</div>
<a class="anchor" id="a3d02d48777a79061869f20ab216a759f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an uninitialized matrix with <em>rows</em> rows and <em>cols</em> columns. </p>
<p>This is useful for dynamic-size matrices. For fixed-size matrices, it is redundant to pass these parameters, so one should use the default constructor <a class="el" href="classEigen_1_1Matrix.html#a3aede62f513da27e6f61ae7a972b4f96" title="Default constructor. ">Matrix()</a> instead. </p>

</div>
</div>
<a class="anchor" id="ad77e097b777eaa2daf25c9292ca15015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor for generic expressions. </p>
<dl class="section see"><dt>See Also</dt><dd>MatrixBase::operator=(const EigenBase&lt;OtherDerived&gt;&amp;) </dd></dl>

</div>
</div>
<a class="anchor" id="a80f437faa158729792ccbd6f0c023d9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a>&lt; OtherDerived, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a Dim x Dim rotation matrix from the rotation <em>r</em>. </p>
<p>This is defined in the Geometry module.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Geometry&gt;</span> </div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3cbc7e8bccd9a8736af1a9968dec74d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp; _set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the value of the expression <em>other</em> into <code>*this</code> with automatic resizing. </p>
<p>*this might be resized to match the dimensions of <em>other</em>. If *this was a null matrix (not already initialized), it will be initialized.</p>
<p>Note that copying a row-vector into a vector (and conversely) is allowed. The resizing, if any, is then done in the appropriate way so that row-vectors remain row-vectors and vectors remain vectors.</p>
<dl class="section see"><dt>See Also</dt><dd>operator=(const MatrixBase&lt;OtherDerived&gt;&amp;), _set_noalias() </dd></dl>

<p>References <a class="el" href="group__flags.html#gadc8925e67a5a54bd479d6f587112e19a">Eigen::EvalBeforeAssigningBit</a>.</p>

</div>
</div>
<a class="anchor" id="aea914316af61df197f21629e14e7870a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if all coefficients are true</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line">Vector3f boxMin(<a class="code" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Vector3f::Zero</a>()), boxMax(<a class="code" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Vector3f::Ones</a>());</div>
<div class="line">Vector3f p0 = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Vector3f::Random</a>(), p1 = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Vector3f::Random</a>().cwiseAbs();</div>
<div class="line"><span class="comment">// let&#39;s check if p0 and p1 are inside the axis aligned box defined by the corners boxMin,boxMax:</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Is (&quot;</span> &lt;&lt; p0.transpose() &lt;&lt; <span class="stringliteral">&quot;) inside the box: &quot;</span></div>
<div class="line">     &lt;&lt; ((boxMin.array()&lt;p0.array()).<a class="code" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a>() &amp;&amp; (boxMax.array()&gt;p0.array()).<a class="code" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a>()) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Is (&quot;</span> &lt;&lt; p1.transpose() &lt;&lt; <span class="stringliteral">&quot;) inside the box: &quot;</span></div>
<div class="line">     &lt;&lt; ((boxMin.array()&lt;p1.array()).<a class="code" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a>() &amp;&amp; (boxMax.array()&gt;p1.array()).<a class="code" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all</a>()) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Is (  0.68 -0.211  0.566) inside the box: 0
Is (0.597 0.823 0.605) inside the box: 1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a42571e028736ca9103bac8b50f269824">any()</a>, Cwise::operator&lt;() </dd></dl>

<p>References <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Eigen::Dynamic</a>.</p>

</div>
</div>
<a class="anchor" id="ac1dba91a5de689327121c20af5a5c18a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool allFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if <code>*this</code> contains only finite numbers, i.e., no NaN and no +/-INF values.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aa867b1db3fb2dd56e7072c7684960ff7">hasNaN()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a42571e028736ca9103bac8b50f269824"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool any </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if at least one coefficient is true</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all()</a> </dd></dl>

<p>References <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Eigen::Dynamic</a>.</p>

</div>
</div>
<a class="anchor" id="a4545be7a9af33ba337a4ebb0101395fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1ArrayWrapper.html">ArrayWrapper</a>&lt;<a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classEigen_1_1ArrayBase.html">Array </a> expression of this matrix </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>ArrayBase::matrix() </dd></dl>

</div>
</div>
<a class="anchor" id="ac00eb88e0d7599b8a2881715d3e4b35f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;CustomBinaryOp, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; , const OtherDerived&gt; binaryExpr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomBinaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomBinaryOp()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a custom coefficient-wise operator <em>func</em> of *this and <em>other</em> </dd></dl>
<p>The template parameter <em>CustomBinaryOp</em> is the type of the functor of the custom operator (see class CwiseBinaryOp for an example)</p>
<p>Here is an example illustrating the use of custom functors: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="comment">// define a custom template binary functor</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt; <span class="keyword">struct </span>MakeComplexOp {</div>
<div class="line">  EIGEN_EMPTY_STRUCT_CTOR(MakeComplexOp)</div>
<div class="line">  typedef complex&lt;Scalar&gt; result_type;</div>
<div class="line">  complex&lt;Scalar&gt; operator()(const Scalar&amp; a, const Scalar&amp; b)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> complex&lt;Scalar&gt;(a,b); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = Matrix4d::Random(), m2 = Matrix4d::Random();</div>
<div class="line">  cout &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#ac00eb88e0d7599b8a2881715d3e4b35f">binaryExpr</a>(m2, MakeComplexOp&lt;double&gt;()) &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">   (0.68,0.271)  (0.823,-0.967) (-0.444,-0.687)   (-0.27,0.998)
 (-0.211,0.435) (-0.605,-0.514)  (0.108,-0.198) (0.0268,-0.563)
 (0.566,-0.717)  (-0.33,-0.726) (-0.0452,-0.74)  (0.904,0.0259)
  (0.597,0.214)   (0.536,0.608)  (0.258,-0.782)   (0.832,0.678)
</pre><dl class="section see"><dt>See Also</dt><dd>class CwiseBinaryOp, <a class="el" href="classEigen_1_1MatrixBase.html#a32e1169b1338aa7edcc9a2dd69882ede">operator+()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a7f53ae2f5586a75f1747d84822ae9581">operator-()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ae759f49ab64f4d454e591bf610a09156">cwiseProduct()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1dbaa2fc7b809720407130f48dfacf8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived&gt; block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a block in *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block </td></tr>
    <tr><td class="paramname">blockRows</td><td>the number of rows in the block </td></tr>
    <tr><td class="paramname">blockCols</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.block(1, 1, 2, 2):&quot;</span> &lt;&lt; endl &lt;&lt; m.block(1, 1, 2, 2) &lt;&lt; endl;</div>
<div class="line">m.block(1, 1, 2, 2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.block(1, 1, 2, 2):
-6  1
-3  0
Now the matrix m is:
 7  9 -5 -3
-2  0  0  0
 6  0  0  9
 6  6  3  9
</pre><dl class="section note"><dt>Note</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size matrix, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a3e433315822db2811a65e88c70672743">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ace64451d903a49f7627cb3b87257c801"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived&gt; block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a3e433315822db2811a65e88c70672743"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived, BlockRows, BlockCols&gt; block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of a block in *this.</dd></dl>
<p>The template parameters <em>BlockRows</em> and <em>BlockCols</em> are the number of rows and columns in the block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.block&lt;2,2&gt;(1,1):&quot;</span> &lt;&lt; endl &lt;&lt; m.block&lt;2,2&gt;(1,1) &lt;&lt; endl;</div>
<div class="line">m.block&lt;2,2&gt;(1,1).<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.block&lt;2,2&gt;(1,1):
-6  1
-3  0
Now the matrix m is:
 7  9 -5 -3
-2  0  0  0
 6  0  0  9
 6  6  3  9
</pre><dl class="section note"><dt>Note</dt><dd>since block is a templated member, the keyword template has to be used if the matrix type is also a template parameter:<div class="fragment"><div class="line">m.template block&lt;3,3&gt;(1,1); </div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a40f9466c400c6dc5779380124e37bf7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived, BlockRows, BlockCols&gt; block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a3e433315822db2811a65e88c70672743">block&lt;&gt;(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a9d35d793f33794df591242d942f98d65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived, BlockRows, BlockCols&gt; block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a block in *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BlockRows</td><td>number of rows in block as specified at compile-time </td></tr>
    <tr><td class="paramname">BlockCols</td><td>number of columns in block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the first row in the block </td></tr>
    <tr><td class="paramname">startCol</td><td>the first column in the block </td></tr>
    <tr><td class="paramname">blockRows</td><td>number of rows in block as specified at run-time </td></tr>
    <tr><td class="paramname">blockCols</td><td>number of columns in block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for blocks where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em>blockRows</em> should equal <em>BlockRows</em> unless <em>BlockRows</em> is <em>Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the block:&quot;</span> &lt;&lt; endl &lt;&lt; m.block&lt;2, <a class="code" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;(1, 1, 2, 3) &lt;&lt; endl;</div>
<div class="line">m.block&lt;2, <a class="code" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;(1, 1, 2, 3).<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Matrix4i m = Matrix4i::Random();
cout &lt;&lt; "Here is the matrix m:" &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; "Here is the block:" &lt;&lt; endl &lt;&lt; m.block&lt;2, Dynamic&gt;(1, 1, 2, 3) &lt;&lt; endl;
m.block&lt;2, Dynamic&gt;(1, 1, 2, 3).setZero();
cout &lt;&lt; "Now the matrix m is:" &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a13fc71e26059f25c5a0de1ebbdfe3375"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived, BlockRows, BlockCols&gt; block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>blockCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block&lt;&gt;(Index, Index, Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a641cf096441faf5ab490c4973c719c7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived&gt; bottomLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a bottom-left corner of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomLeftCorner(2, 2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.bottomLeftCorner(2, 2) &lt;&lt; endl;</div>
<div class="line">m.bottomLeftCorner(2, 2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomLeftCorner(2, 2):
 6 -3
 6  6
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  9
 0  0  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abd00a289a3033ba0802cb55c23910874"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived&gt; bottomLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a641cf096441faf5ab490c4973c719c7a">bottomLeftCorner(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a243a44832e36d2bf5d0d8d17d1505900"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived, CRows, CCols&gt; bottomLeftCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size bottom-left corner of *this.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomLeftCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.bottomLeftCorner&lt;2,2&gt;() &lt;&lt; endl;</div>
<div class="line">m.bottomLeftCorner&lt;2,2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomLeftCorner&lt;2,2&gt;():
 6 -3
 6  6
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  9
 0  0  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7fa849b36665dcca6316f05a634e6540"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived, CRows, CCols&gt; bottomLeftCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a243a44832e36d2bf5d0d8d17d1505900">bottomLeftCorner&lt;int, int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a7a305fa6d02685ea21c9050617d837d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived, CRows, CCols&gt; bottomLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a bottom-left corner of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em>cRows</em> should equal <em>CRows</em> unless <em>CRows</em> is <em>Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomLeftCorner&lt;2,Dynamic&gt;(2,2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.bottomLeftCorner&lt;2,<a class="code" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;(2,2) &lt;&lt; endl;</div>
<div class="line">m.bottomLeftCorner&lt;2,<a class="code" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;(2,2).<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomLeftCorner&lt;2,Dynamic&gt;(2,2):
 6 -3
 6  6
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  9
 0  0  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a878151caf2ff25ebbc76186485f81207"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived, CRows, CCols&gt; bottomLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a641cf096441faf5ab490c4973c719c7a">bottomLeftCorner&lt;int, int&gt;(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a2b9618f3c9eb4d4c9813ae8f6a8e70c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived&gt; bottomRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a bottom-right corner of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomRightCorner(2, 2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.bottomRightCorner(2, 2) &lt;&lt; endl;</div>
<div class="line">m.bottomRightCorner(2, 2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomRightCorner(2, 2):
0 9
3 9
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  0
 6  6  0  0
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a26cfa9c974065fc714cdaf7a5fdbe1ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived&gt; bottomRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a2b9618f3c9eb4d4c9813ae8f6a8e70c5">bottomRightCorner(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a6563b16b601d9fd66340ab04d101f9d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived, CRows, CCols&gt; bottomRightCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size bottom-right corner of *this.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomRightCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.bottomRightCorner&lt;2,2&gt;() &lt;&lt; endl;</div>
<div class="line">m.bottomRightCorner&lt;2,2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomRightCorner&lt;2,2&gt;():
0 9
3 9
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  0
 6  6  0  0
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa0b8870679a8b100f24a8eecf1ac3477"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived, CRows, CCols&gt; bottomRightCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a6563b16b601d9fd66340ab04d101f9d1">bottomRightCorner&lt;int, int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a13b796ff9732af7ec072455513480bd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived, CRows, CCols&gt; bottomRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a bottom-right corner of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em>cRows</em> should equal <em>CRows</em> unless <em>CRows</em> is <em>Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.bottomRightCorner&lt;2,Dynamic&gt;(2,2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.bottomRightCorner&lt;2,<a class="code" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;(2,2) &lt;&lt; endl;</div>
<div class="line">m.bottomRightCorner&lt;2,<a class="code" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;(2,2).<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.bottomRightCorner&lt;2,Dynamic&gt;(2,2):
0 9
3 9
Now the matrix m is:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  0
 6  6  0  0
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10f1d3781d0dbcf80b79087c5acad5f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived, CRows, CCols&gt; bottomRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a2b9618f3c9eb4d4c9813ae8f6a8e70c5">bottomRightCorner&lt;int, int&gt;(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="afe61d23353a75d7034f7b44ff02aaea1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RowsBlockXpr bottomRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the bottom rows of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line">Array44i a = Array44i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.bottomRows(2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; a.bottomRows(2) &lt;&lt; endl;</div>
<div class="line">a.bottomRows(2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.bottomRows(2):
 6 -3  0  9
 6  6  3  9
Now the array a is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  0
 0  0  0  0
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5959de43ccb180fbd4ad44002441a52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstRowsBlockXpr bottomRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#afe61d23353a75d7034f7b44ff02aaea1">bottomRows(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="ac0d50068b3e133e938202f4e23445aba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NRowsBlockXpr&lt;N&gt;::Type bottomRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the bottom rows of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of rows in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p>
<div class="fragment"><div class="line">Array44i a = Array44i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.bottomRows&lt;2&gt;():&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; a.bottomRows&lt;2&gt;() &lt;&lt; endl;</div>
<div class="line">a.bottomRows&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.bottomRows&lt;2&gt;():
 6 -3  0  9
 6  6  3  9
Now the array a is:
 7  9 -5 -3
-2 -6  1  0
 0  0  0  0
 0  0  0  0
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab75475e30affe582fc16e256741a4f1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstNRowsBlockXpr&lt;N&gt;::Type bottomRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#afe61d23353a75d7034f7b44ff02aaea1">bottomRows&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a660200abaf1fc4b888330a37d6132b76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::cast_return_type&lt;<a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; ,const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_cast_op&lt;typename internal::traits&lt;<a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt;::Scalar, NewType&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; &gt;::type cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with the <em>Scalar</em> type casted to <em>NewScalar</em>.</dd></dl>
<p>The template parameter <em>NewScalar</em> is the type we are casting the scalars to.</p>
<dl class="section see"><dt>See Also</dt><dd>class CwiseUnaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="a58c77695de3b33405f01f2fdf3dc389d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ColXpr col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the <em>i-th</em> column of *this. Note that the numbering starts at 0.</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = <a class="code" href="classEigen_1_1MatrixBase.html#a0650b65c6ae6c3d19a138b72a6d68568">Matrix3d::Identity</a>();</div>
<div class="line">m.col(1) = <a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a>(4,5,6);</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">1 4 0
0 5 0
0 6 1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row()</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

<p>Referenced by <a class="el" href="classEigen_1_1VectorwiseOp.html#a93a7a9d23fc28219f5dd82f3f90222ca">VectorwiseOp&lt; ExpressionType, Direction &gt;::cross()</a>.</p>

</div>
</div>
<a class="anchor" id="a390f7c534678354959dd587080b82c2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstColXpr col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col()</a>. </p>

</div>
</div>
<a class="anchor" id="a49a617f24129ca31a27fe8a67ec20370"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1VectorwiseOp.html">ConstColwiseReturnType</a> colwise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations. ">VectorwiseOp</a> wrapper of *this providing additional partial reduction operations</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each column:&quot;</span> &lt;&lt; endl &lt;&lt; m.colwise().sum() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum absolute value of each column:&quot;</span></div>
<div class="line">     &lt;&lt; endl &lt;&lt; m.cwiseAbs().colwise().maxCoeff() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the sum of each column:
  1.04  0.815 -0.238
Here is the maximum absolute value of each column:
 0.68 0.823 0.536
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a8a7fd1e8004d4bd93a7ea36957aa8e99">rowwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations. ">VectorwiseOp</a>, <a class="el" href="group__TutorialReductionsVisitorsBroadcasting.html">Reductions, visitors and broadcasting</a> </dd></dl>

<p>Referenced by <a class="el" href="group__Geometry__Module.html#gab3f5a82a24490b936f8694cf8fef8e60">Eigen::umeyama()</a>.</p>

</div>
</div>
<a class="anchor" id="abe7ae69362c464b6721adbb47c655874"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1VectorwiseOp.html">ColwiseReturnType</a> colwise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations. ">VectorwiseOp</a> wrapper of *this providing additional partial reduction operations</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a8a7fd1e8004d4bd93a7ea36957aa8e99">rowwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations. ">VectorwiseOp</a>, <a class="el" href="group__TutorialReductionsVisitorsBroadcasting.html">Reductions, visitors and broadcasting</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aab6c2241712d7faf07019a0d86d3fb79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConjugateReturnType conjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the complex conjugate of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ac43d5834cffcedbd27777329a8f5eeca">adjoint()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4ac24a195e3e35ce2d8946cee5873e51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void conservativeResize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix to <em>rows</em> x <em>cols</em> while leaving old values untouched.</p>
<p>The method is intended for matrices of dynamic size. If you only want to change the number of rows and/or of columns, you can use <a class="el" href="classEigen_1_1PlainObjectBase.html#abbf58a9ff956976fb3a26d2a0f6a9dc3">conservativeResize(NoChange_t, Index)</a> or <a class="el" href="classEigen_1_1PlainObjectBase.html#ae238393021f2b8298b1fb1c094ccb290">conservativeResize(Index, NoChange_t)</a>.</p>
<p>Matrices are resized relative to the top-left element. In case values need to be appended to the matrix they will be uninitialized. </p>

</div>
</div>
<a class="anchor" id="ae238393021f2b8298b1fb1c094ccb290"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void conservativeResize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoChange_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix to <em>rows</em> x <em>cols</em> while leaving old values untouched.</p>
<p>As opposed to <a class="el" href="classEigen_1_1PlainObjectBase.html#a4ac24a195e3e35ce2d8946cee5873e51">conservativeResize(Index rows, Index cols)</a>, this version leaves the number of columns unchanged.</p>
<p>In case the matrix is growing, new rows will be uninitialized. </p>

<p>References <a class="el" href="classEigen_1_1PlainObjectBase.html#a4ac24a195e3e35ce2d8946cee5873e51">PlainObjectBase&lt; Derived &gt;::conservativeResize()</a>.</p>

</div>
</div>
<a class="anchor" id="abbf58a9ff956976fb3a26d2a0f6a9dc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void conservativeResize </td>
          <td>(</td>
          <td class="paramtype">NoChange_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix to <em>rows</em> x <em>cols</em> while leaving old values untouched.</p>
<p>As opposed to <a class="el" href="classEigen_1_1PlainObjectBase.html#a4ac24a195e3e35ce2d8946cee5873e51">conservativeResize(Index rows, Index cols)</a>, this version leaves the number of rows unchanged.</p>
<p>In case the matrix is growing, new columns will be uninitialized. </p>

<p>References <a class="el" href="classEigen_1_1PlainObjectBase.html#a4ac24a195e3e35ce2d8946cee5873e51">PlainObjectBase&lt; Derived &gt;::conservativeResize()</a>.</p>

</div>
</div>
<a class="anchor" id="a3202c9faf8977ca71a9b53ef4e4cc70b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void conservativeResize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the vector to <em>size</em> while retaining old values.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.. This method does not work for partially dynamic matrices when the static dimension is anything other than 1. For example it will not work with Matrix&lt;double, 2, Dynamic&gt;.</p>
<p>When values are appended, they will be uninitialized. </p>

</div>
</div>
<a class="anchor" id="a55aac6d6465a7c6b67b10aba69a6da54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void conservativeResizeLike </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix to <em>rows</em> x <em>cols</em> of <code>other</code>, while leaving old values untouched.</p>
<p>The method is intended for matrices of dynamic size. If you only want to change the number of rows and/or of columns, you can use <a class="el" href="classEigen_1_1PlainObjectBase.html#abbf58a9ff956976fb3a26d2a0f6a9dc3">conservativeResize(NoChange_t, Index)</a> or <a class="el" href="classEigen_1_1PlainObjectBase.html#ae238393021f2b8298b1fb1c094ccb290">conservativeResize(Index, NoChange_t)</a>.</p>
<p>Matrices are resized relative to the top-left element. In case values need to be appended to the matrix they will copied from <code>other</code>. </p>

</div>
</div>
<a class="anchor" id="abb7652b9ae2c6ee26be9db276613c4f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType Constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a constant matrix of value <em>value</em> </dd></dl>
<p>The parameters <em>nbRows</em> and <em>nbCols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays. ">DenseBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>nbRows</em> and <em>nbCols</em> as arguments, so <a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero()</a> should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

<p>References <a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">DenseBase&lt; Derived &gt;::NullaryExpr()</a>.</p>

</div>
</div>
<a class="anchor" id="aa07edf1aa85b7e84bd6b15158efbca71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType Constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a constant matrix of value <em>value</em> </dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays. ">DenseBase</a> type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so <a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero()</a> should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

<p>References <a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">DenseBase&lt; Derived &gt;::NullaryExpr()</a>.</p>

</div>
</div>
<a class="anchor" id="aa3647a2091ca73b864aee4126118fd44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType Constant </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a constant matrix of value <em>value</em> </dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays. ">DenseBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

<p>References <a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">DenseBase&lt; Derived &gt;::NullaryExpr()</a>.</p>

</div>
</div>
<a class="anchor" id="aa671b5ea336ba21a7644d3fa6577ee00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of coefficients which evaluate to true</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aea914316af61df197f21629e14e7870a">all()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a42571e028736ca9103bac8b50f269824">any()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4d8398a4497e4a888cfc11c51c14a81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_abs_op&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; cwiseAbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise absolute value of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line">MatrixXd m(2,3);</div>
<div class="line">m &lt;&lt; 2, -4, 6,   </div>
<div class="line">     -5, 1, 0;</div>
<div class="line">cout &lt;&lt; m.cwiseAbs() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">2 4 6
5 1 0
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#abc9cb99dcb93caf0c3c37860aeef30b2">cwiseAbs2()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc9cb99dcb93caf0c3c37860aeef30b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_abs2_op&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; cwiseAbs2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise squared absolute value of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line">MatrixXd m(2,3);</div>
<div class="line">m &lt;&lt; 2, -4, 6,   </div>
<div class="line">     -5, 1, 0;</div>
<div class="line">cout &lt;&lt; m.cwiseAbs2() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 4 16 36
25  1  0
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ab4d8398a4497e4a888cfc11c51c14a81">cwiseAbs()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2373e043b49396e152523e85b0a2ace8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;std::equal_to&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; , const OtherDerived&gt; cwiseEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise == operator of *this and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a> and isMuchSmallerThan().</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga5b9d0d11e78fd355d23221154b7620e4">MatrixXi</a> m(2,2);</div>
<div class="line">m &lt;&lt; 1, 0,</div>
<div class="line">     1, 1;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Comparing m with identity matrix:&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.cwiseEqual(MatrixXi::Identity(2,2)) &lt;&lt; endl;</div>
<div class="line"><span class="keywordtype">int</span> count = m.cwiseEqual(MatrixXi::Identity(2,2)).count();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Number of coefficients that are equal: &quot;</span> &lt;&lt; count &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Comparing m with identity matrix:
1 1
0 1
Number of coefficients that are equal: 3
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ac3f5276480c741953c66498a078ecd30">cwiseNotEqual()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a>, isMuchSmallerThan() </dd></dl>

</div>
</div>
<a class="anchor" id="ae1f241762b604c2117232c5c994068bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;std::binder1st&lt;std::equal_to&lt;Scalar&gt; &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; cwiseEqual </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise == operator of <code>*this</code> and a scalar <em>s</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a> and isMuchSmallerThan().</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a2373e043b49396e152523e85b0a2ace8">cwiseEqual(const MatrixBase&lt;OtherDerived&gt; &amp;) const</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a433cd5f8e17b2662c4081ec798fa54be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_inverse_op&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; cwiseInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise inverse of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line">MatrixXd m(2,3);</div>
<div class="line">m &lt;&lt; 2, 0.5, 1,   </div>
<div class="line">     3, 0.25, 1;</div>
<div class="line">cout &lt;&lt; m.cwiseInverse() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">  0.5     2     1
0.333     4     1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ae759f49ab64f4d454e591bf610a09156">cwiseProduct()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa1a53029c0ee62fb8875ce3c12151eda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_max_op&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; , const OtherDerived&gt; cwiseMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise max of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a> v(2,3,4), w(4,2,3);</div>
<div class="line">cout &lt;&lt; v.cwiseMax(w) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">4
3
4
</pre><dl class="section see"><dt>See Also</dt><dd>class CwiseBinaryOp, min() </dd></dl>

</div>
</div>
<a class="anchor" id="a7e985c7a4f692584865b9ec9e7d5780c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_max_op&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; , const ConstantReturnType&gt; cwiseMax </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise max of *this and scalar <em>other</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class CwiseBinaryOp, min() </dd></dl>

</div>
</div>
<a class="anchor" id="afc17a621f5682e6eba6a1c439174d550"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_min_op&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; , const OtherDerived&gt; cwiseMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise min of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a> v(2,3,4), w(4,2,3);</div>
<div class="line">cout &lt;&lt; v.cwiseMin(w) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">2
2
3
</pre><dl class="section see"><dt>See Also</dt><dd>class CwiseBinaryOp, max() </dd></dl>

</div>
</div>
<a class="anchor" id="ac02d0af0ea867d6b1cc0cc4db0e1d480"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_min_op&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; , const ConstantReturnType&gt; cwiseMin </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise min of *this and scalar <em>other</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class CwiseBinaryOp, min() </dd></dl>

</div>
</div>
<a class="anchor" id="ac3f5276480c741953c66498a078ecd30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;std::not_equal_to&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; , const OtherDerived&gt; cwiseNotEqual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise != operator of *this and <em>other</em> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this performs an exact comparison, which is generally a bad idea with floating-point types. In order to check for equality between two vectors or matrices with floating-point coefficients, it is generally a far better idea to use a fuzzy comparison as provided by <a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a> and isMuchSmallerThan().</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga5b9d0d11e78fd355d23221154b7620e4">MatrixXi</a> m(2,2);</div>
<div class="line">m &lt;&lt; 1, 0,</div>
<div class="line">     1, 1;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Comparing m with identity matrix:&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.cwiseNotEqual(MatrixXi::Identity(2,2)) &lt;&lt; endl;</div>
<div class="line"><span class="keywordtype">int</span> count = m.cwiseNotEqual(MatrixXi::Identity(2,2)).count();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Number of coefficients that are not equal: &quot;</span> &lt;&lt; count &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Comparing m with identity matrix:
0 0
1 0
Number of coefficients that are not equal: 1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#ae1f241762b604c2117232c5c994068bb">cwiseEqual()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a>, isMuchSmallerThan() </dd></dl>

</div>
</div>
<a class="anchor" id="ae759f49ab64f4d454e591bf610a09156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_product_op&lt;typename <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt;  ::Scalar, typename OtherDerived ::Scalar &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt;  , const OtherDerived &gt; cwiseProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the Schur product (coefficient wise product) of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga4b6688615f30a9959be0285115080c3d">Matrix3i</a> a = Matrix3i::Random(), b = Matrix3i::Random();</div>
<div class="line"><a class="code" href="group__matrixtypedefs.html#ga4b6688615f30a9959be0285115080c3d">Matrix3i</a> c = a.cwiseProduct(b);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;a:\n&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;\nb:\n&quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;\nc:\n&quot;</span> &lt;&lt; c &lt;&lt; endl;</div>
<div class="line"></div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">a:
 7  6 -3
-2  9  6
 6 -6 -5
b:
 1 -3  9
 0  0  3
 3  9  5
c:
  7 -18 -27
  0   0  18
 18 -54 -25
</pre><dl class="section see"><dt>See Also</dt><dd>class CwiseBinaryOp, <a class="el" href="classEigen_1_1MatrixBase.html#abc9cb99dcb93caf0c3c37860aeef30b2">cwiseAbs2</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa36bff7d4e9186e4fbed250b15ad9e36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt;internal::scalar_quotient_op&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; , const OtherDerived&gt; cwiseQuotient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise quotient of *this and <em>other</em> </dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a> v(2,3,4), w(4,2,3);</div>
<div class="line">cout &lt;&lt; v.cwiseQuotient(w) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 0.5
 1.5
1.33
</pre><dl class="section see"><dt>See Also</dt><dd>class CwiseBinaryOp, <a class="el" href="classEigen_1_1MatrixBase.html#ae759f49ab64f4d454e591bf610a09156">cwiseProduct()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#a433cd5f8e17b2662c4081ec798fa54be">cwiseInverse()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a88945ad7d126468c10e299e896bf0d1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_sqrt_op&lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; cwiseSqrt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise square root of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a> v(1,2,4);</div>
<div class="line">cout &lt;&lt; v.cwiseSqrt() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">   1
1.41
   2
</pre><dl class="section see"><dt>See Also</dt><dd>cwisePow(), cwiseSquare() </dd></dl>

</div>
</div>
<a class="anchor" id="a40dcc334db75411e168691d9bce08c3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Scalar* data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the data array of this matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a4663159a1450fa89214b1ab71f7ef5bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar* data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the data array of this matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a41c29f54b9da54e37fbe1756a0da7013"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> diagonalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the main diagonal, which is min(rows(),cols()). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>rows(), cols(), <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eab30be5c02d7a124ec165d2ab6c5b05ed">SizeAtCompileTime</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cb26f170dd440dfafe11117cf826334"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EvalReturnType eval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix or vector obtained by evaluating this expression.</dd></dl>
<p>Notice that in the case of a plain matrix or vector (not an expression) this function just returns a const reference, in order to avoid a useless copy. </p>

</div>
</div>
<a class="anchor" id="a98692bec8f3d859f1e7a60eab87ac571"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fill </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for <a class="el" href="classEigen_1_1DenseBase.html#a351ca566980cf96d9cdd61f3ce0cf94f">setConstant()</a>: sets all coefficients in this expression to <em>val</em>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a351ca566980cf96d9cdd61f3ce0cf94f">setConstant()</a>, <a class="el" href="classEigen_1_1DenseBase.html#abb7652b9ae2c6ee26be9db276613c4f6">Constant()</a>, class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

<p>Referenced by <a class="el" href="classEigen_1_1PermutationBase.html#a021fa8725bf6224f20a8670afabb6bcd">PermutationBase&lt; PermutationMatrix&lt; SizeAtCompileTime, MaxSizeAtCompileTime, IndexType &gt; &gt;::determinant()</a>.</p>

</div>
</div>
<a class="anchor" id="afcbba97b05d9a88657783dfc4f931f3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Flagged&lt; Derived, Added, Removed &gt; flagged </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of *this with added and removed flags</dd></dl>
<p>This is mostly for internal use.</p>
<dl class="section see"><dt>See Also</dt><dd>class Flagged </dd></dl>

</div>
</div>
<a class="anchor" id="aa364b60e6a2a124ea7392e4c0550fb4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1WithFormat.html">WithFormat</a>&lt; Derived &gt; format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1IOFormat.html">IOFormat</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classEigen_1_1WithFormat.html" title="Pseudo expression providing matrix output with given format. ">WithFormat</a> proxy object allowing to print a matrix the with given format <em>fmt</em>.</dd></dl>
<p>See class <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed. ">IOFormat</a> for some examples.</p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed. ">IOFormat</a>, class <a class="el" href="classEigen_1_1WithFormat.html" title="Pseudo expression providing matrix output with given format. ">WithFormat</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa867b1db3fb2dd56e7072c7684960ff7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasNaN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true is <code>*this</code> contains at least one Not A Number (NaN).</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ac1dba91a5de689327121c20af5a5c18a">allFinite()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade4c5211a2be02bbf477352228b323ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SegmentReturnType head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of the first coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">RowVector4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.head(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.head(2) &lt;&lt; endl;</div>
<div class="line">v.head(2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.head(2):
 7 -2
Now the vector v is:
0 0 6 6
</pre><dl class="section note"><dt>Note</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a3e433315822db2811a65e88c70672743">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a41fa0eb5d46891f2345ff7cc9f3fe99b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstSegmentReturnType head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#ade4c5211a2be02bbf477352228b323ae">head(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="afab7d7b04a8ab7fbe7dce61513c70492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedSegmentReturnType&lt;N&gt;::Type head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of the first coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of coefficients in the segment as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">RowVector4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.head(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.head&lt;2&gt;() &lt;&lt; endl;</div>
<div class="line">v.head&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.head(2):
 7 -2
Now the vector v is:
0 0 6 6
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5d574a75a1054b05804862f847ec32de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstFixedSegmentReturnType&lt;N&gt;::Type head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#ade4c5211a2be02bbf477352228b323ae">head&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a01069a930197aeca3b13b44bdc426c7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ImagReturnType imag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an read-only expression of the imaginary part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#accfa15407b80807dab914b1844c725e5">real()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1032121a2fc5fcc5f006f976413378f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NonConstImagReturnType imag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non const expression of the imaginary part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#accfa15407b80807dab914b1844c725e5">real()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acd9791e1914ad8761992e16032d49c54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> innerSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner size.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For a vector, this is just the size. For a matrix (non-vector), this is the minor dimension with respect to the <a class="el" href="group__TopicStorageOrders.html">storage order</a>, i.e., the number of rows for a column-major matrix, and the number of columns for a row-major matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a158c2184951e6e415c2e9b98db8e8966"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isApprox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> is approximately equal to <em>other</em>, within the precision determined by <em>prec</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The fuzzy compares are done multiplicatively. Two vectors <img class="formulaInl" alt="$ v $" src="form_13.png"/> and <img class="formulaInl" alt="$ w $" src="form_14.png"/> are considered to be approximately equal within precision <img class="formulaInl" alt="$ p $" src="form_15.png"/> if <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Vert v - w \Vert \leqslant p\,\min(\Vert v\Vert, \Vert w\Vert). \]" src="form_16.png"/>
</p>
 For matrices, the comparison is done using the Hilbert-Schmidt norm (aka Frobenius norm L2 norm).</dd>
<dd>
Because of the multiplicativeness of this comparison, one can't use this function to check whether <code>*this</code> is approximately equal to the zero matrix or vector. Indeed, <code>isApprox(zero)</code> returns false unless <code>*this</code> itself is exactly the zero matrix or vector. If you want to test whether <code>*this</code> is zero, use internal::isMuchSmallerThan(const RealScalar&amp;, RealScalar) instead.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>internal::isMuchSmallerThan(const RealScalar&amp;, RealScalar) const </dd></dl>

<p>Referenced by <a class="el" href="classEigen_1_1Transform.html#a970e36d17bd859badeacfbe73bc7364b">Transform&lt; Scalar, Dim, Mode, _Options &gt;::isApprox()</a>.</p>

</div>
</div>
<a class="anchor" id="aed2515d3d813e1355933b6e0def44640"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isApproxToConstant </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if all coefficients in this matrix are approximately equal to <em>val</em>, to within precision <em>prec</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a045c430069e53c7589e71fcc6984c8a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isConstant </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is just an alias for <a class="el" href="classEigen_1_1DenseBase.html#aed2515d3d813e1355933b6e0def44640">isApproxToConstant()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if all coefficients in this matrix are approximately equal to <em>value</em>, to within precision <em>prec</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a40b9e8df68a52b2d46cf70c9babf2a16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isMuchSmallerThan </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt; Scalar &gt;::Real &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the norm of <code>*this</code> is much smaller than <em>other</em>, within the precision determined by <em>prec</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The fuzzy compares are done multiplicatively. A vector <img class="formulaInl" alt="$ v $" src="form_13.png"/> is considered to be much smaller than <img class="formulaInl" alt="$ x $" src="form_17.png"/> within precision <img class="formulaInl" alt="$ p $" src="form_15.png"/> if <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Vert v \Vert \leqslant p\,\vert x\vert. \]" src="form_18.png"/>
</p>
</dd></dl>
<p>For matrices, the comparison is done using the Hilbert-Schmidt norm. For this reason, the value of the reference scalar <em>other</em> should come from the Hilbert-Schmidt norm of a reference matrix of same dimensions.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a>, isMuchSmallerThan(const DenseBase&lt;OtherDerived&gt;&amp;, RealScalar) const </dd></dl>

</div>
</div>
<a class="anchor" id="aaa59b5a40da397d905789cf99bce18d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isMuchSmallerThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the norm of <code>*this</code> is much smaller than the norm of <em>other</em>, within the precision determined by <em>prec</em>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The fuzzy compares are done multiplicatively. A vector <img class="formulaInl" alt="$ v $" src="form_13.png"/> is considered to be much smaller than a vector <img class="formulaInl" alt="$ w $" src="form_14.png"/> within precision <img class="formulaInl" alt="$ p $" src="form_15.png"/> if <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Vert v \Vert \leqslant p\,\Vert w\Vert. \]" src="form_19.png"/>
</p>
 For matrices, the comparison is done using the Hilbert-Schmidt norm.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a>, isMuchSmallerThan(const RealScalar&amp;, RealScalar) const </dd></dl>

</div>
</div>
<a class="anchor" id="a34b4423fdfdf0c0644268095c55fe6ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isOnes </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to the matrix where all coefficients are equal to 1, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Matrix3d::Ones</a>();</div>
<div class="line">m(0,2) += 1e-4;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isOnes() returns: &quot;</span> &lt;&lt; m.isOnes() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isOnes(1e-3) returns: &quot;</span> &lt;&lt; m.isOnes(1e-3) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here's the matrix m:
1 1 1
1 1 1
1 1 1
m.isOnes() returns: 0
m.isOnes(1e-3) returns: 1
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a>, <a class="el" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Ones()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6dc0eb069536157ead1d46c660b9622d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isZero </td>
          <td>(</td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>prec</em> = <code><a class="el" href="structEigen_1_1NumTraits.html">NumTraits</a>&lt;Scalar&gt;::dummy_precision()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if *this is approximately equal to the zero matrix, within the precision given by <em>prec</em>.</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Matrix3d::Zero</a>();</div>
<div class="line">m(0,2) = 1e-4;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here&#39;s the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isZero() returns: &quot;</span> &lt;&lt; m.isZero() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.isZero(1e-3) returns: &quot;</span> &lt;&lt; m.isZero(1e-3) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here's the matrix m:
     0      0 0.0001
     0      0      0
     0      0      0
m.isZero() returns: 0
m.isZero(1e-3) returns: 1
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a>, <a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a468be7f76aaf518d692d9888a00ad23b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp; lazyAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd>MatrixBase::lazyAssign() </dd></dl>

</div>
</div>
<a class="anchor" id="ace4288d22b0312944ec93c8c46474ef6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ColsBlockXpr leftCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the left columns of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line">Array44i a = Array44i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.leftCols(2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; a.leftCols(2) &lt;&lt; endl;</div>
<div class="line">a.leftCols(2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.leftCols(2):
 7  9
-2 -6
 6 -3
 6  6
Now the array a is:
 0  0 -5 -3
 0  0  1  0
 0  0  0  9
 0  0  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa43a2f7ef9b8029727a3e0424fd4e57d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstColsBlockXpr leftCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#ace4288d22b0312944ec93c8c46474ef6">leftCols(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="af915090ee1e32d74dc6a9037e7b36c5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NColsBlockXpr&lt;N&gt;::Type leftCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the left columns of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of columns in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p>
<div class="fragment"><div class="line">Array44i a = Array44i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.leftCols&lt;2&gt;():&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; a.leftCols&lt;2&gt;() &lt;&lt; endl;</div>
<div class="line">a.leftCols&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.leftCols&lt;2&gt;():
 7  9
-2 -6
 6 -3
 6  6
Now the array a is:
 0  0 -5 -3
 0  0  1  0
 0  0  0  9
 0  0  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a27392d7a73eae182c766938c93c13ef2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstNColsBlockXpr&lt;N&gt;::Type leftCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#ace4288d22b0312944ec93c8c46474ef6">leftCols&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a03a4ddf48fc9f3674a783da9c6ae34d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::SequentialLinSpacedReturnType LinSpaced </td>
          <td>(</td>
          <td class="paramtype">Sequential_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly space vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. This particular version of <a class="el" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8" title="Sets a linearly space vector. ">LinSpaced()</a> uses sequential access, i.e. vector access is assumed to be a(0), a(1), ..., a(size). This assumption allows for better vectorization and yields faster code than the random access version.</p>
<p>When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; VectorXi::LinSpaced(Sequential,4,7,10).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">VectorXd::LinSpaced</a>(Sequential,5,0.0,1.0).transpose() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 7  8  9 10
   0 0.25  0.5 0.75    1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aca96b3050ceeffaa781d3d4ee185bd1d" title="Sets a linearly space vector. ">setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, LinSpaced(Index,Scalar,Scalar), <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

<p>References <a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">DenseBase&lt; Derived &gt;::NullaryExpr()</a>.</p>

</div>
</div>
<a class="anchor" id="add3a25508eab3a05851a3b4208b96eb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomAccessLinSpacedReturnType LinSpaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly space vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; VectorXi::LinSpaced(4,7,10).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">VectorXd::LinSpaced</a>(5,0.0,1.0).transpose() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 7  8  9 10
   0 0.25  0.5 0.75    1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aca96b3050ceeffaa781d3d4ee185bd1d" title="Sets a linearly space vector. ">setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, LinSpaced(Sequential_t,Index,const Scalar&amp;,const Scalar&amp;,Index), <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

<p>References <a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">DenseBase&lt; Derived &gt;::NullaryExpr()</a>.</p>

</div>
</div>
<a class="anchor" id="a30ceb9d76f8ca3ff5bc71f7797b9788d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::SequentialLinSpacedReturnType LinSpaced </td>
          <td>(</td>
          <td class="paramtype">Sequential_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly space vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. This particular version of <a class="el" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8" title="Sets a linearly space vector. ">LinSpaced()</a> uses sequential access, i.e. vector access is assumed to be a(0), a(1), ..., a(size). This assumption allows for better vectorization and yields faster code than the random access version.</p>
<p>When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; VectorXi::LinSpaced(Sequential,4,7,10).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">VectorXd::LinSpaced</a>(Sequential,5,0.0,1.0).transpose() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 7  8  9 10
   0 0.25  0.5 0.75    1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aca96b3050ceeffaa781d3d4ee185bd1d" title="Sets a linearly space vector. ">setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, LinSpaced(Index,Scalar,Scalar), <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> Special version for fixed size types which does not require the size parameter. </dd></dl>

<p>References <a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">DenseBase&lt; Derived &gt;::NullaryExpr()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0e2ccb6cded6a7aa927c3410aee071b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::RandomAccessLinSpacedReturnType LinSpaced </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly space vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; VectorXi::LinSpaced(4,7,10).transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">VectorXd::LinSpaced</a>(5,0.0,1.0).transpose() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 7  8  9 10
   0 0.25  0.5 0.75    1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aca96b3050ceeffaa781d3d4ee185bd1d" title="Sets a linearly space vector. ">setLinSpaced(Index,const Scalar&amp;,const Scalar&amp;)</a>, LinSpaced(Sequential_t,Index,const Scalar&amp;,const Scalar&amp;,Index), <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> Special version for fixed size types which does not require the size parameter. </dd></dl>

<p>References <a class="el" href="classEigen_1_1DenseBase.html#a138e37f3c338a544afb347aaf80d32da">DenseBase&lt; Derived &gt;::NullaryExpr()</a>.</p>

</div>
</div>
<a class="anchor" id="a878f0dae18b28d8158c5f1c232edced2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::Scalar maxCoeff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum of all coefficients of <code>*this</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the result is undefined if <code>*this</code> contains NaN. </dd></dl>

</div>
</div>
<a class="anchor" id="aad851ef369d212dcea81d9cded12dbdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::Scalar maxCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>rowPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>colPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum of all coefficients of *this and puts in *row and *col its location. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>DenseBase::minCoeff(IndexType*,IndexType*), DenseBase::visitor(), <a class="el" href="classEigen_1_1DenseBase.html#a878f0dae18b28d8158c5f1c232edced2">DenseBase::maxCoeff()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0b381dbcb0435c3a34a78abad4726cc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::Scalar maxCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the maximum of all coefficients of *this and puts in *index its location. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>DenseBase::maxCoeff(IndexType*,IndexType*), DenseBase::minCoeff(IndexType*,IndexType*), DenseBase::visitor(), <a class="el" href="classEigen_1_1DenseBase.html#a878f0dae18b28d8158c5f1c232edced2">DenseBase::maxCoeff()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0af2b3991862a079e3efaef3e4d17d96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::Scalar mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the mean of all coefficients of *this</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>trace(), <a class="el" href="classEigen_1_1DenseBase.html#a6bdcbfa7e3b07d3246ad80de7170b0f5">prod()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a3a3b3fb530d3364ecef0bf9c9daf0983">sum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2d4f5da8e2019251ad3ed876d363d5d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ColsBlockXpr middleCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>numCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of columns of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startCol</td><td>the index of the first column in the block </td></tr>
    <tr><td class="paramname">numCols</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;</div>
<div class="line">    <a class="code" href="classEigen_1_1Matrix.html">MatrixXi</a> A(N,N);</div>
<div class="line">    A.<a class="code" href="classEigen_1_1PlainObjectBase.html#ae1ce0775cd60a0bf2eda0902fc7fc9bd">setRandom</a>();</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A(1..3,:) =\n&quot;</span> &lt;&lt; A.<a class="code" href="classEigen_1_1DenseBase.html#a2d4f5da8e2019251ad3ed876d363d5d1">middleCols</a>(1,3) &lt;&lt; endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(1..3,:) =
-6  0  9
-3  3  3
 6 -3  5
-5  0 -8
 1  9  2
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a428643f7e51813faa8c8ad89b8282235"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstColsBlockXpr middleCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>numCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a2d4f5da8e2019251ad3ed876d363d5d1">middleCols(Index,Index)</a>. </p>

</div>
</div>
<a class="anchor" id="aa257ee10f662780e48cd9cec53bbbb86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NColsBlockXpr&lt;N&gt;::Type middleCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of columns of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of columns in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startCol</td><td>the index of the first column in the block </td></tr>
    <tr><td class="paramname">n</td><td>the number of columns in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;</div>
<div class="line">    <a class="code" href="classEigen_1_1Matrix.html">MatrixXi</a> A(N,N);</div>
<div class="line">    A.<a class="code" href="classEigen_1_1PlainObjectBase.html#ae1ce0775cd60a0bf2eda0902fc7fc9bd">setRandom</a>();</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A(:,1..3) =\n&quot;</span> &lt;&lt; A.<a class="code" href="classEigen_1_1DenseBase.html#a2d4f5da8e2019251ad3ed876d363d5d1">middleCols</a>&lt;3&gt;(1) &lt;&lt; endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(:,1..3) =
-6  0  9
-3  3  3
 6 -3  5
-5  0 -8
 1  9  2
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad95bf75ae40119637a809d02bf53e4da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstNColsBlockXpr&lt;N&gt;::Type middleCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startCol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a2d4f5da8e2019251ad3ed876d363d5d1">middleCols&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="aee53d4065b9aa5164ea8e5fe9459a779"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RowsBlockXpr middleRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of rows of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the index of the first row in the block </td></tr>
    <tr><td class="paramname">n</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;</div>
<div class="line">    <a class="code" href="classEigen_1_1Matrix.html">MatrixXi</a> A(N,N);</div>
<div class="line">    A.<a class="code" href="classEigen_1_1PlainObjectBase.html#ae1ce0775cd60a0bf2eda0902fc7fc9bd">setRandom</a>();</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A(2..3,:) =\n&quot;</span> &lt;&lt; A.<a class="code" href="classEigen_1_1DenseBase.html#aee53d4065b9aa5164ea8e5fe9459a779">middleRows</a>(2,2) &lt;&lt; endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(2..3,:) =
 6  6 -3  5 -8
 6 -5  0 -8  6
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a491f1ff40224dd1aa37d26cb42438cc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstRowsBlockXpr middleRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#aee53d4065b9aa5164ea8e5fe9459a779">middleRows(Index,Index)</a>. </p>

</div>
</div>
<a class="anchor" id="af0876bbd4a94f44008452fd9486cc26c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NRowsBlockXpr&lt;N&gt;::Type middleRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of a range of rows of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of rows in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startRow</td><td>the index of the first row in the block </td></tr>
    <tr><td class="paramname">n</td><td>the number of rows in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> N = 5;</div>
<div class="line">    <a class="code" href="classEigen_1_1Matrix.html">MatrixXi</a> A(N,N);</div>
<div class="line">    A.<a class="code" href="classEigen_1_1PlainObjectBase.html#ae1ce0775cd60a0bf2eda0902fc7fc9bd">setRandom</a>();</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A =\n&quot;</span> &lt;&lt; A &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; endl;</div>
<div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;A(1..3,:) =\n&quot;</span> &lt;&lt; A.<a class="code" href="classEigen_1_1DenseBase.html#aee53d4065b9aa5164ea8e5fe9459a779">middleRows</a>&lt;3&gt;(1) &lt;&lt; endl;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">A =
  7  -6   0   9 -10
 -2  -3   3   3  -5
  6   6  -3   5  -8
  6  -5   0  -8   6
  9   1   9   2  -7

A(1..3,:) =
-2 -3  3  3 -5
 6  6 -3  5 -8
 6 -5  0 -8  6
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a244977920d9254b31da36bb05b0057c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstNRowsBlockXpr&lt;N&gt;::Type middleRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>startRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#aee53d4065b9aa5164ea8e5fe9459a779">middleRows&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="add6cb2d85282829eb9adc9565ce784d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::Scalar minCoeff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum of all coefficients of <code>*this</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the result is undefined if <code>*this</code> contains NaN. </dd></dl>

</div>
</div>
<a class="anchor" id="ad927d600371ba16dcb44518530ba906a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::Scalar minCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>rowId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>colId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum of all coefficients of *this and puts in *row and *col its location. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>DenseBase::minCoeff(Index*), DenseBase::maxCoeff(Index*,Index*), DenseBase::visitor(), <a class="el" href="classEigen_1_1DenseBase.html#add6cb2d85282829eb9adc9565ce784d6">DenseBase::minCoeff()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae959fb7401b9cfdf900ff3b295466526"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::Scalar minCoeff </td>
          <td>(</td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimum of all coefficients of *this and puts in *index its location. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the result is undefined if <code>*this</code> contains NaN.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>DenseBase::minCoeff(IndexType*,IndexType*), DenseBase::maxCoeff(IndexType*,IndexType*), DenseBase::visitor(), <a class="el" href="classEigen_1_1DenseBase.html#add6cb2d85282829eb9adc9565ce784d6">DenseBase::minCoeff()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a324b9263b40738a260d46ff011b8d31b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1NestByValue.html">NestByValue</a>&lt; Derived &gt; nestByValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the temporary version of *this. </dd></dl>

</div>
</div>
<a class="anchor" id="abe29bfb5f2d88cf2a50ffb577ec6f0a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> nonZeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of nonzero coefficients which is in practice the number of stored coefficients. </dd></dl>

</div>
</div>
<a class="anchor" id="a138e37f3c338a544afb347aaf80d32da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, Derived &gt; NullaryExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomNullaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix defined by a custom functor <em>func</em> </dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero()</a> should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

<p>Referenced by <a class="el" href="classEigen_1_1DenseBase.html#abb7652b9ae2c6ee26be9db276613c4f6">DenseBase&lt; Derived &gt;::Constant()</a>, <a class="el" href="classEigen_1_1MatrixBase.html#ac836fdaa36fbf51080ca710d682ef039">MatrixBase&lt; Derived &gt;::Identity()</a>, and <a class="el" href="classEigen_1_1DenseBase.html#a03a4ddf48fc9f3674a783da9c6ae34d8">DenseBase&lt; Derived &gt;::LinSpaced()</a>.</p>

</div>
</div>
<a class="anchor" id="ae50fd894930b4f917cf5c40f23965f67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, Derived &gt; NullaryExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CustomNullaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix defined by a custom functor <em>func</em> </dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so <a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero()</a> should be used instead.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a24025debf13d8352eb963b814e08b5e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; CustomNullaryOp, Derived &gt; NullaryExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomNullaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix defined by a custom functor <em>func</em> </dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1DenseBase.html" title="Base class for all dense matrices, vectors, and arrays. ">DenseBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>The template parameter <em>CustomNullaryOp</em> is the type of the functor.</p>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad148f93a6a00e32ef00903c5393337ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType Ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a matrix where all coefficients equal one.</dd></dl>
<p>The parameters <em>nbRows</em> and <em>nbCols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Ones()</a> should be used instead.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">MatrixXi::Ones</a>(2,3) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">1 1 1
1 1 1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Ones()</a>, <a class="el" href="classEigen_1_1DenseBase.html#adec530c086d6b585ebb009fe4fbb77e6">Ones(Index)</a>, <a class="el" href="classEigen_1_1DenseBase.html#a34b4423fdfdf0c0644268095c55fe6ea">isOnes()</a>, class <a class="el" href="classEigen_1_1DenseBase.html#ad148f93a6a00e32ef00903c5393337ef">Ones</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adec530c086d6b585ebb009fe4fbb77e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType Ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a vector where all coefficients equal one.</dd></dl>
<p>The parameter <em>newSize</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so <a class="el" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Ones()</a> should be used instead.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; 6 * <a class="code" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">RowVectorXi::Ones</a>(4) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">VectorXf::Ones</a>(2) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">6 6 6 6
1
1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Ones()</a>, <a class="el" href="classEigen_1_1DenseBase.html#ad148f93a6a00e32ef00903c5393337ef">Ones(Index,Index)</a>, <a class="el" href="classEigen_1_1DenseBase.html#a34b4423fdfdf0c0644268095c55fe6ea">isOnes()</a>, class <a class="el" href="classEigen_1_1DenseBase.html#ad148f93a6a00e32ef00903c5393337ef">Ones</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2278addf9a3c977d40322571a0df8ac9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType Ones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size matrix or vector where all coefficients equal one.</dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Matrix2d::Ones</a>() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; 6 * <a class="code" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">RowVector4i::Ones</a>() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">1 1
1 1
6 6 6 6
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#adec530c086d6b585ebb009fe4fbb77e6">Ones(Index)</a>, <a class="el" href="classEigen_1_1DenseBase.html#ad148f93a6a00e32ef00903c5393337ef">Ones(Index,Index)</a>, <a class="el" href="classEigen_1_1DenseBase.html#a34b4423fdfdf0c0644268095c55fe6ea">isOnes()</a>, class <a class="el" href="classEigen_1_1DenseBase.html#ad148f93a6a00e32ef00903c5393337ef">Ones</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5648a35b9610ad47cb01912752db1dae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if at least one pair of coefficients of <code>*this</code> and <em>other</em> are not exactly equal to each other. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When using floating point scalar values you probably should rather use a fuzzy comparison such as <a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a>, operator== </dd></dl>

</div>
</div>
<a class="anchor" id="ae8ab11fb1ef0822aa61527f7ecd77b9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ScalarMultipleReturnType operator* </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> scaled by the scalar factor <em>scalar</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a01a3dfc024abbb42150002facf498357"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_multiple2_op&lt;Scalar,std::complex&lt;Scalar&gt; &gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded for efficient real matrix times complex scalar value </p>

</div>
</div>
<a class="anchor" id="a32e1169b1338aa7edcc9a2dd69882ede"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_sum_op &lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; , const OtherDerived&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the sum of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to add a given scalar to all coefficients, see Cwise::operator+().</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class CwiseBinaryOp, <a class="el" href="classEigen_1_1MatrixBase.html#a7aaf408b3bfbdd38749b01979393e814">operator+=()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2dab56059c2cd13fd3b36668a58fc1ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseBinaryOp.html">CwiseBinaryOp</a>&lt; internal::scalar_difference_op &lt;Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; , const OtherDerived&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">Eigen::MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the difference of <code>*this</code> and <em>other</em> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you want to substract a given scalar from all coefficients, see Cwise::operator-().</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class CwiseBinaryOp, <a class="el" href="classEigen_1_1MatrixBase.html#a2da6ae5caa522c1efec3a75428b22143">operator-=()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f53ae2f5586a75f1747d84822ae9581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_opposite_op&lt;typename internal::traits&lt;<a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt;::Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the opposite of <code>*this</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae78e46db7ee3ba78d3cf59968d261f90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;internal::scalar_quotient1_op&lt;typename internal::traits&lt;<a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt;::Scalar&gt;, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of <code>*this</code> divided by the scalar value <em>scalar</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ade5d2e09de50c2ca145037f295542b16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="anchor" id="MatrixBaseCommaInitRef"></a>Convenient operator to set the coefficients of a matrix.</p>
<p>The coefficients must be provided in a row major order and exactly match the size of the matrix. Otherwise an assertion is raised.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga4b6688615f30a9959be0285115080c3d">Matrix3i</a> m1;</div>
<div class="line">m1 &lt;&lt; 1, 2, 3,</div>
<div class="line">      4, 5, 6,</div>
<div class="line">      7, 8, 9;</div>
<div class="line">cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"><a class="code" href="group__matrixtypedefs.html#ga4b6688615f30a9959be0285115080c3d">Matrix3i</a> m2 = <a class="code" href="classEigen_1_1MatrixBase.html#a0650b65c6ae6c3d19a138b72a6d68568">Matrix3i::Identity</a>();</div>
<div class="line">m2.block(0,0, 2,2) &lt;&lt; 10, 11, 12, 13;</div>
<div class="line">cout &lt;&lt; m2 &lt;&lt; endl &lt;&lt; endl;</div>
<div class="line"><a class="code" href="group__matrixtypedefs.html#gae4b211eebc55d300139b0e6e34a06cba">Vector2i</a> v1;</div>
<div class="line">v1 &lt;&lt; 14, 15;</div>
<div class="line">m2 &lt;&lt; v1.transpose(), 16,</div>
<div class="line">      v1, m1.block(1,1,2,2);</div>
<div class="line">cout &lt;&lt; m2 &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">1 2 3
4 5 6
7 8 9

10 11  0
12 13  0
 0  0  1

14 15 16
14  5  6
15  8  9
</pre><dl class="section note"><dt>Note</dt><dd>According the c++ standard, the argument expressions of this comma initializer are evaluated in arbitrary order.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structEigen_1_1CommaInitializer.html#a1f065adc0c5e868f62cea827286f6d40">CommaInitializer::finished()</a>, class <a class="el" href="structEigen_1_1CommaInitializer.html" title="Helper class used by the comma initializer operator. ">CommaInitializer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3dacded5374fe30f8d4eb4ae18bc87c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEigen_1_1CommaInitializer.html">CommaInitializer</a>&lt; Derived &gt; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ade5d2e09de50c2ca145037f295542b16">operator&lt;&lt;(const Scalar&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad0cefab13f61a9dfd2733a7da70a264e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns matrices to each other. </p>
<dl class="section note"><dt>Note</dt><dd>This is a special case of the templated operator=. Its purpose is to prevent a default operator= from hiding the templated operator=. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8cd84b304d3593c792fcd6fc1f3180f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt;_Scalar, _Rows, _Cols, _Storage, _MaxRows, _MaxCols&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1RotationBase.html">RotationBase</a>&lt; OtherDerived, <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6eae943bdba893721a848dfcd03db756b22">ColsAtCompileTime</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a Dim x Dim rotation matrix from the rotation <em>r</em>. </p>
<p>This is defined in the Geometry module.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Geometry&gt;</span> </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="af83f0a4a9e94b8ab5183aa9398e97539"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the generic expression <em>other</em> into *this. </p>
<p>The expression must provide a (templated) evalTo(Derived&amp; dst) const function which does the actual job. In practice, this allows any user to write its own special matrix without having to modify <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a></p>
<dl class="section return"><dt>Returns</dt><dd>a reference to *this. </dd></dl>

</div>
</div>
<a class="anchor" id="a78f22189db1a4cc4634bb8427ae64f06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1MatrixBase.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if each coefficients of <code>*this</code> and <em>other</em> are all exactly equal. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When using floating point scalar values you probably should rather use a fuzzy comparison such as <a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a158c2184951e6e415c2e9b98db8e8966">isApprox()</a>, operator!= </dd></dl>

</div>
</div>
<a class="anchor" id="af080d3d3f82e0d4391f19af22a5eedb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> outerSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if either the number of rows or the number of columns is equal to 1. In other words, this function returns <div class="fragment"><div class="line">rows()==1 || cols()==1 </div>
</div><!-- fragment --> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd>rows(), cols(), <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea7e22277c8f0a1a76dd0d6c62e366b59f">IsVectorAtCompileTime</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the outer size.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For a vector, this returns just 1. For a matrix (non-vector), this is the major dimension with respect to the <a class="el" href="group__TopicStorageOrders.html">storage order</a>, i.e., the number of columns for a column-major matrix, and the number of rows for a row-major matrix. </dd></dl>

<p>References <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea247b0f8b0eb0bfd5e253eb1e4b61436b">DenseBase&lt; Derived &gt;::IsRowMajor</a>, and <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea7e22277c8f0a1a76dd0d6c62e366b59f">DenseBase&lt; Derived &gt;::IsVectorAtCompileTime</a>.</p>

</div>
</div>
<a class="anchor" id="a6bdcbfa7e3b07d3246ad80de7170b0f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::Scalar prod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the product of all coefficients of *this</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the product of all the coefficients:&quot;</span> &lt;&lt; endl &lt;&lt; m.prod() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the product of all the coefficients:
0.0019
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a3a3b3fb530d3364ecef0bf9c9daf0983">sum()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a0af2b3991862a079e3efaef3e4d17d96">mean()</a>, trace() </dd></dl>

<p>References <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Eigen::Dynamic</a>.</p>

</div>
</div>
<a class="anchor" id="a78061942c4ccb57f5b1dde173fdd8bd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; internal::scalar_random_op&lt; typename internal::traits&lt; Derived &gt;::Scalar &gt;, Derived &gt; Random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a random matrix expression</dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Random()</a> should be used instead.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">MatrixXi::Random</a>(2,3) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 7  6  9
-2  6 -6
</pre><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary matrix whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ab795c242db18862f502dfd9fa625c504">MatrixBase::setRandom()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a6f42aba8fbe2618deb0e80e4af876e04">MatrixBase::Random(Index)</a>, <a class="el" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">MatrixBase::Random()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6f42aba8fbe2618deb0e80e4af876e04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; internal::scalar_random_op&lt; typename internal::traits&lt; Derived &gt;::Scalar &gt;, Derived &gt; Random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a random vector expression</dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so <a class="el" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Random()</a> should be used instead.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; VectorXi::Random(2) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 7
-2
</pre><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary vector whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ab795c242db18862f502dfd9fa625c504">MatrixBase::setRandom()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a78061942c4ccb57f5b1dde173fdd8bd0">MatrixBase::Random(Index,Index)</a>, <a class="el" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">MatrixBase::Random()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8e759dafdd9ecc446d397b7f5435f60a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseNullaryOp.html">CwiseNullaryOp</a>&lt; internal::scalar_random_op&lt; typename internal::traits&lt; Derived &gt;::Scalar &gt;, Derived &gt; Random </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size random matrix or vector expression</dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; 100 * <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix2i::Random</a>() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 700  600
-200  600
</pre><p>This expression has the "evaluate before nesting" flag so that it will be evaluated into a temporary matrix whenever it is nested in a larger expression. This prevents unexpected behavior with expressions involving random matrices.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#ab795c242db18862f502dfd9fa625c504">MatrixBase::setRandom()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a78061942c4ccb57f5b1dde173fdd8bd0">MatrixBase::Random(Index,Index)</a>, <a class="el" href="classEigen_1_1DenseBase.html#a6f42aba8fbe2618deb0e80e4af876e04">MatrixBase::Random(Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4a1c87f8e48a66edc05859421048f8b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RealReturnType real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a read-only expression of the real part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a1032121a2fc5fcc5f006f976413378f8">imag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="accfa15407b80807dab914b1844c725e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NonConstRealReturnType real </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non const expression of the real part of <code>*this</code>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1MatrixBase.html#a1032121a2fc5fcc5f006f976413378f8">imag()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a64248a8479a46b78fa5b19702aa5d212"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::result_of&lt;Func(typename internal::traits&lt;Derived&gt;::Scalar)&gt;::type redux </td>
          <td>(</td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the result of a full redux operation on the whole matrix or vector using <em>func</em> </dd></dl>
<p>The template parameter <em>BinaryOp</em> is the type of the functor <em>func</em> which must be an associative operator. Both current STL and TR1 functor styles are handled.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a3a3b3fb530d3364ecef0bf9c9daf0983">DenseBase::sum()</a>, <a class="el" href="classEigen_1_1DenseBase.html#add6cb2d85282829eb9adc9565ce784d6">DenseBase::minCoeff()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a878f0dae18b28d8158c5f1c232edced2">DenseBase::maxCoeff()</a>, <a class="el" href="classEigen_1_1DenseBase.html#abe7ae69362c464b6721adbb47c655874">MatrixBase::colwise()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a8a7fd1e8004d4bd93a7ea36957aa8e99">MatrixBase::rowwise()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afca0e8ff7921ee0e3ab4422818ecb214"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Replicate.html">Replicate</a>&lt; Derived, RowFactor, ColFactor &gt; replicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga5b9d0d11e78fd355d23221154b7620e4">MatrixXi</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">MatrixXi::Random</a>(2,3);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m.replicate&lt;3,2&gt;() = ...&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.replicate&lt;3,2&gt;() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  6  9
-2  6 -6
m.replicate&lt;3,2&gt;() = ...
 7  6  9  7  6  9
-2  6 -6 -2  6 -6
 7  6  9  7  6  9
-2  6 -6 -2  6 -6
 7  6  9  7  6  9
-2  6 -6 -2  6 -6
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a9a078997c488c2d83fbd45108af26e1d">VectorwiseOp::replicate()</a>, DenseBase::replicate(Index,Index), class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector. ">Replicate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d2cad18a5459a6c98563defff4e3d0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1Replicate.html">ReplicateReturnType</a> replicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>rowFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>colFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the replication of <code>*this</code> </dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gaa4931fe5bb599038466be823fdfadd04">Vector3i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Vector3i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;v.replicate(2,5) = ...&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; v.replicate(2,5) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the vector v:
 7
-2
 6
v.replicate(2,5) = ...
 7  7  7  7  7
-2 -2 -2 -2 -2
 6  6  6  6  6
 7  7  7  7  7
-2 -2 -2 -2 -2
 6  6  6  6  6
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1VectorwiseOp.html#a9a078997c488c2d83fbd45108af26e1d">VectorwiseOp::replicate()</a>, <a class="el" href="classEigen_1_1DenseBase.html#afca0e8ff7921ee0e3ab4422818ecb214">DenseBase::replicate&lt;int,int&gt;()</a>, class <a class="el" href="classEigen_1_1Replicate.html" title="Expression of the multiple replication of a matrix or vector. ">Replicate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbbb33d14fe7fb9683019a39ce1c659d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes <code>*this</code> to a <em>rows</em> x <em>cols</em> matrix.</p>
<p>This method is intended for dynamic-size matrices, although it is legal to call it on any matrix as long as fixed dimensions are left unchanged. If you only want to change the number of rows and/or of columns, you can use <a class="el" href="classEigen_1_1PlainObjectBase.html#aec9ca3c51c341a06bce3451ff1adc84d">resize(NoChange_t, Index)</a>, <a class="el" href="classEigen_1_1PlainObjectBase.html#a58d9d13dd3982d05458767072c257886">resize(Index, NoChange_t)</a>.</p>
<p>If the current number of coefficients of <code>*this</code> exactly matches the product <em>rows</em> * <em>cols</em>, then no memory allocation is performed and the current values are left unchanged. In all other cases, including shrinking, the data is reallocated and all previous values are lost.</p>
<p>Example: </p>
<div class="fragment"><div class="line">MatrixXd m(2,3);</div>
<div class="line">m &lt;&lt; 1,2,3,4,5,6;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;here&#39;s the 2x3 matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;let&#39;s resize m to 3x2. This is a conservative resizing because 2*3==3*2.&quot;</span> &lt;&lt; endl;</div>
<div class="line">m.resize(3,2);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;here&#39;s the 3x2 matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;now let&#39;s resize m to size 2x2. This is NOT a conservative resizing, so it becomes uninitialized:&quot;</span> &lt;&lt; endl;</div>
<div class="line">m.resize(2,2);</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">here's the 2x3 matrix m:
1 2 3
4 5 6
let's resize m to 3x2. This is a conservative resizing because 2*3==3*2.
here's the 3x2 matrix m:
1 5
4 3
2 6
now let's resize m to size 2x2. This is NOT a conservative resizing, so it becomes uninitialized:
6.94e-310 2.12e-314
4.94e-324 4.94e-323
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1PlainObjectBase.html#a0b8db206b78137e95dc0833952ed1ed0">resize(Index)</a> for vectors, <a class="el" href="classEigen_1_1PlainObjectBase.html#aec9ca3c51c341a06bce3451ff1adc84d">resize(NoChange_t, Index)</a>, <a class="el" href="classEigen_1_1PlainObjectBase.html#a58d9d13dd3982d05458767072c257886">resize(Index, NoChange_t)</a> </dd></dl>

<p>References <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Eigen::Dynamic</a>.</p>

</div>
</div>
<a class="anchor" id="a0b8db206b78137e95dc0833952ed1ed0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes <code>*this</code> to a vector of length <em>size</em> </p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.. This method does not work for partially dynamic matrices when the static dimension is anything other than 1. For example it will not work with Matrix&lt;double, 2, Dynamic&gt;.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga3da45e59796fbacf67fa568297927bd1">VectorXd</a> v(10);</div>
<div class="line">v.resize(3);</div>
<div class="line"><a class="code" href="group__matrixtypedefs.html#gae986937bbeec1aa1291655f47182813f">RowVector3d</a> w;</div>
<div class="line">w.resize(3); <span class="comment">// this is legal, but has no effect</span></div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;v: &quot;</span> &lt;&lt; v.rows() &lt;&lt; <span class="stringliteral">&quot; rows, &quot;</span> &lt;&lt; v.cols() &lt;&lt; <span class="stringliteral">&quot; cols&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;w: &quot;</span> &lt;&lt; w.rows() &lt;&lt; <span class="stringliteral">&quot; rows, &quot;</span> &lt;&lt; w.cols() &lt;&lt; <span class="stringliteral">&quot; cols&quot;</span> &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">v: 3 rows, 1 cols
w: 1 rows, 3 cols
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1PlainObjectBase.html#afbbb33d14fe7fb9683019a39ce1c659d">resize(Index,Index)</a>, <a class="el" href="classEigen_1_1PlainObjectBase.html#aec9ca3c51c341a06bce3451ff1adc84d">resize(NoChange_t, Index)</a>, <a class="el" href="classEigen_1_1PlainObjectBase.html#a58d9d13dd3982d05458767072c257886">resize(Index, NoChange_t)</a> </dd></dl>

<p>References <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Eigen::Dynamic</a>.</p>

</div>
</div>
<a class="anchor" id="aec9ca3c51c341a06bce3451ff1adc84d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype">NoChange_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix, changing only the number of columns. For the parameter of type NoChange_t, just pass the special value <code>NoChange</code> as in the example below.</p>
<p>Example: </p>
<div class="fragment"><div class="line">MatrixXd m(3,4);</div>
<div class="line">m.resize(NoChange, 5);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m: &quot;</span> &lt;&lt; m.rows() &lt;&lt; <span class="stringliteral">&quot; rows, &quot;</span> &lt;&lt; m.cols() &lt;&lt; <span class="stringliteral">&quot; cols&quot;</span> &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">m: 3 rows, 5 cols
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1PlainObjectBase.html#afbbb33d14fe7fb9683019a39ce1c659d">resize(Index,Index)</a> </dd></dl>

<p>References <a class="el" href="classEigen_1_1PlainObjectBase.html#afbbb33d14fe7fb9683019a39ce1c659d">PlainObjectBase&lt; Derived &gt;::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a58d9d13dd3982d05458767072c257886"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoChange_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix, changing only the number of rows. For the parameter of type NoChange_t, just pass the special value <code>NoChange</code> as in the example below.</p>
<p>Example: </p>
<div class="fragment"><div class="line">MatrixXd m(3,4);</div>
<div class="line">m.resize(5, NoChange);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;m: &quot;</span> &lt;&lt; m.rows() &lt;&lt; <span class="stringliteral">&quot; rows, &quot;</span> &lt;&lt; m.cols() &lt;&lt; <span class="stringliteral">&quot; cols&quot;</span> &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">m: 5 rows, 4 cols
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1PlainObjectBase.html#afbbb33d14fe7fb9683019a39ce1c659d">resize(Index,Index)</a> </dd></dl>

<p>References <a class="el" href="classEigen_1_1PlainObjectBase.html#afbbb33d14fe7fb9683019a39ce1c659d">PlainObjectBase&lt; Derived &gt;::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="abe7b7417203825a6e434449cf0ac6529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resizeLike </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEigen_1_1EigenBase.html">EigenBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>_other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes <code>*this</code> to have the same dimensions as <em>other</em>. Takes care of doing all the checking that's needed.</p>
<p>Note that copying a row-vector into a vector (and conversely) is allowed. The resizing, if any, is then done in the appropriate way so that row-vectors remain row-vectors and vectors remain vectors. </p>

<p>References <a class="el" href="structEigen_1_1EigenBase.html#aa84222add803ad7c9db07dd4dd91d5d9">EigenBase&lt; Derived &gt;::derived()</a>, and <a class="el" href="classEigen_1_1PlainObjectBase.html#afbbb33d14fe7fb9683019a39ce1c659d">PlainObjectBase&lt; Derived &gt;::resize()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e354bb81f0c7b6888c6a0ce4b4649e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1Reverse.html">ReverseReturnType</a> reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the reverse of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga5b9d0d11e78fd355d23221154b7620e4">MatrixXi</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">MatrixXi::Random</a>(3,4);</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the reverse of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.reverse() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the coefficient (1,0) in the reverse of m:&quot;</span> &lt;&lt; endl</div>
<div class="line">     &lt;&lt; m.reverse()(1,0) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Let us overwrite this coefficient with the value 4.&quot;</span> &lt;&lt; endl;</div>
<div class="line">m.reverse()(1,0) = 4;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  6 -3  1
-2  9  6  0
 6 -6 -5  3
Here is the reverse of m:
 3 -5 -6  6
 0  6  9 -2
 1 -3  6  7
Here is the coefficient (1,0) in the reverse of m:
0
Let us overwrite this coefficient with the value 4.
Now the matrix m is:
 7  6 -3  1
-2  9  6  4
 6 -6 -5  3
</pre> 
</div>
</div>
<a class="anchor" id="ae3a4b984747fa12de0f521b3bff907b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1Reverse.html">ConstReverseReturnType</a> reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a6e354bb81f0c7b6888c6a0ce4b4649e2">reverse()</a>. </p>

</div>
</div>
<a class="anchor" id="af148c4e77e657d04573c4fda43740ed5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reverseInPlace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the "in place" version of reverse: it reverses <code>*this</code>.</p>
<p>In most cases it is probably better to simply use the reversed expression of a matrix. However, when reversing the matrix data itself is really needed, then this "in-place" version is probably the right choice because it provides the following additional features:</p>
<ul>
<li>less error prone: doing the same operation with .<a class="el" href="classEigen_1_1DenseBase.html#a6e354bb81f0c7b6888c6a0ce4b4649e2">reverse()</a> requires special care: <div class="fragment"><div class="line">m = m.reverse().eval(); </div>
</div><!-- fragment --></li>
<li>this API allows to avoid creating a temporary (the current implementation creates a temporary, but that could be avoided using swap)</li>
<li>it allows future optimizations (cache friendliness, etc.)</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a6e354bb81f0c7b6888c6a0ce4b4649e2">reverse()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af80f9e4e3708d7e3b0e1487ca90cf339"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ColsBlockXpr rightCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the right columns of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line">Array44i a = Array44i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.rightCols(2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; a.rightCols(2) &lt;&lt; endl;</div>
<div class="line">a.rightCols(2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.rightCols(2):
-5 -3
 1  0
 0  9
 3  9
Now the array a is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  0
 6  6  0  0
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad16081d19c5482a30aa6be15769e8056"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstColsBlockXpr rightCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#af80f9e4e3708d7e3b0e1487ca90cf339">rightCols(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a3400066e9b6d285f5214748b6332a7a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NColsBlockXpr&lt;N&gt;::Type rightCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the right columns of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of columns in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of columns in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p>
<div class="fragment"><div class="line">Array44i a = Array44i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.rightCols&lt;2&gt;():&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; a.rightCols&lt;2&gt;() &lt;&lt; endl;</div>
<div class="line">a.rightCols&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.rightCols&lt;2&gt;():
-5 -3
 1  0
 0  9
 3  9
Now the array a is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  0
 6  6  0  0
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a553136b326ce6bdd67ff4610ea20f598"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstNColsBlockXpr&lt;N&gt;::Type rightCols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#af80f9e4e3708d7e3b0e1487ca90cf339">rightCols&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="aa8716d44f51321072ee5c88665c28813"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RowXpr row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the <em>i-th</em> row of *this. Note that the numbering starts at 0.</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = <a class="code" href="classEigen_1_1MatrixBase.html#a0650b65c6ae6c3d19a138b72a6d68568">Matrix3d::Identity</a>();</div>
<div class="line">m.row(1) = <a class="code" href="group__matrixtypedefs.html#ga2006332f6989f501762673e21f5128f5">Vector3d</a>(4,5,6);</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">1 0 0
4 5 6
0 0 1
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a58c77695de3b33405f01f2fdf3dc389d">col()</a>, class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

<p>Referenced by <a class="el" href="classEigen_1_1VectorwiseOp.html#a93a7a9d23fc28219f5dd82f3f90222ca">VectorwiseOp&lt; ExpressionType, Direction &gt;::cross()</a>, and <a class="el" href="classEigen_1_1Transform.html#a2f4920998698b8aadde6f71151ece99c">Transform&lt; Scalar, Dim, Mode, _Options &gt;::pretranslate()</a>.</p>

</div>
</div>
<a class="anchor" id="ad62dcaf648cca25e9318da34c9840799"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstRowXpr row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#aa8716d44f51321072ee5c88665c28813">row()</a>. </p>

</div>
</div>
<a class="anchor" id="a3af2f03b1d2affcec24e0748edf892cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1VectorwiseOp.html">ConstRowwiseReturnType</a> rowwise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations. ">VectorwiseOp</a> wrapper of *this providing additional partial reduction operations</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga45a14b423c687c3e2e8325f148e27bf3">Matrix3d</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix3d::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the sum of each row:&quot;</span> &lt;&lt; endl &lt;&lt; m.rowwise().sum() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the maximum absolute value of each row:&quot;</span></div>
<div class="line">     &lt;&lt; endl &lt;&lt; m.cwiseAbs().rowwise().maxCoeff() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the sum of each row:
 0.948
  1.15
-0.483
Here is the maximum absolute value of each row:
 0.68
0.823
0.605
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#abe7ae69362c464b6721adbb47c655874">colwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations. ">VectorwiseOp</a>, <a class="el" href="group__TutorialReductionsVisitorsBroadcasting.html">Reductions, visitors and broadcasting</a> </dd></dl>

<p>Referenced by <a class="el" href="group__Geometry__Module.html#gab3f5a82a24490b936f8694cf8fef8e60">Eigen::umeyama()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a7fd1e8004d4bd93a7ea36957aa8e99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1VectorwiseOp.html">RowwiseReturnType</a> rowwise </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a writable <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations. ">VectorwiseOp</a> wrapper of *this providing additional partial reduction operations</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#abe7ae69362c464b6721adbb47c655874">colwise()</a>, class <a class="el" href="classEigen_1_1VectorwiseOp.html" title="Pseudo expression providing partial reduction operations. ">VectorwiseOp</a>, <a class="el" href="group__TutorialReductionsVisitorsBroadcasting.html">Reductions, visitors and broadcasting</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9dfa43e5ac3984e38b1dee1f06415003"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SegmentReturnType segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a segment (i.e. a vector block) in *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the first coefficient in the segment </td></tr>
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">RowVector4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.segment(1, 2):&quot;</span> &lt;&lt; endl &lt;&lt; v.segment(1, 2) &lt;&lt; endl;</div>
<div class="line">v.segment(1, 2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.segment(1, 2):
-2  6
Now the vector v is:
7 0 0 6
</pre><dl class="section note"><dt>Note</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, segment(Index) </dd></dl>

</div>
</div>
<a class="anchor" id="a686a182050df26084c0519f9f6633c68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstSegmentReturnType segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a9dfa43e5ac3984e38b1dee1f06415003">segment(Index,Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a57815573b5eeac29e8d12d6136dd05fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedSegmentReturnType&lt;N&gt;::Type segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of a segment (i.e. a vector block) in <code>*this</code> </dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of coefficients in the segment as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the index of the first element in the segment </td></tr>
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment as specified at compile-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">RowVector4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.segment&lt;2&gt;(1):&quot;</span> &lt;&lt; endl &lt;&lt; v.segment&lt;2&gt;(1) &lt;&lt; endl;</div>
<div class="line">v.segment&lt;2&gt;(2).<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.segment&lt;2&gt;(1):
-2  6
Now the vector v is:
 7 -2  0  0
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f4183a7b0211a36ddf2081db7aa4376"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstFixedSegmentReturnType&lt;N&gt;::Type segment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of segment&lt;int&gt;(Index). </p>

</div>
</div>
<a class="anchor" id="aaaed9ab0c7a20c689017542e40d1ef6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, ThenDerived, ElseDerived &gt; select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>thenMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>elseMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a matrix where each coefficient (i,j) is equal to <em>thenMatrix(i,j)</em> if <code>*this</code>(i,j), and <em>elseMatrix(i,j)</em> otherwise.</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga5b9d0d11e78fd355d23221154b7620e4">MatrixXi</a> m(3, 3);</div>
<div class="line">m &lt;&lt; 1, 2, 3,</div>
<div class="line">     4, 5, 6,</div>
<div class="line">     7, 8, 9;</div>
<div class="line">m = (m.array() &gt;= 5).<a class="code" href="classEigen_1_1DenseBase.html#aaaed9ab0c7a20c689017542e40d1ef6e">select</a>(-m, m);</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 1  2  3
 4 -5 -6
-7 -8 -9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Select.html" title="Expression of a coefficient wise version of the C++ ternary operator ?: ">Select</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a59df26fd07b401c361f53d84642d73ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, ThenDerived, typename ThenDerived::ConstantReturnType &gt; select </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ThenDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>thenMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename ThenDerived::Scalar &amp;&#160;</td>
          <td class="paramname"><em>elseScalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Version of DenseBase::select(const DenseBase&amp;, const DenseBase&amp;) with the <em>else</em> expression being a scalar value.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aaaed9ab0c7a20c689017542e40d1ef6e">DenseBase::select(const DenseBase&lt;ThenDerived&gt;&amp;, const DenseBase&lt;ElseDerived&gt;&amp;) const</a>, class <a class="el" href="classEigen_1_1Select.html" title="Expression of a coefficient wise version of the C++ ternary operator ?: ">Select</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adfc67de2ba1403e6856bd1b7dd1388f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Select.html">Select</a>&lt; Derived, typename ElseDerived::ConstantReturnType, ElseDerived &gt; select </td>
          <td>(</td>
          <td class="paramtype">const typename ElseDerived::Scalar &amp;&#160;</td>
          <td class="paramname"><em>thenScalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; ElseDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>elseMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Version of DenseBase::select(const DenseBase&amp;, const DenseBase&amp;) with the <em>then</em> expression being a scalar value.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aaaed9ab0c7a20c689017542e40d1ef6e">DenseBase::select(const DenseBase&lt;ThenDerived&gt;&amp;, const DenseBase&lt;ElseDerived&gt;&amp;) const</a>, class <a class="el" href="classEigen_1_1Select.html" title="Expression of a coefficient wise version of the C++ ternary operator ?: ">Select</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a351ca566980cf96d9cdd61f3ce0cf94f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; setConstant </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to <em>value</em>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a98692bec8f3d859f1e7a60eab87ac571">fill()</a>, setConstant(Index,const Scalar&amp;), setConstant(Index,Index,const Scalar&amp;), <a class="el" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a196e62ee8a1fc3b4af631e955d650cfc">setOnes()</a>, <a class="el" href="classEigen_1_1DenseBase.html#abb7652b9ae2c6ee26be9db276613c4f6">Constant()</a>, class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a>, <a class="el" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a196e62ee8a1fc3b4af631e955d650cfc">setOnes()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aca96b3050ceeffaa781d3d4ee185bd1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; setLinSpaced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly space vector. </p>
<p>The function generates 'size' equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>Example: </p>
<div class="fragment"><div class="line">VectorXf v;</div>
<div class="line">v.setLinSpaced(5,0.5f,1.5f);</div>
<div class="line">cout &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 0.5
0.75
   1
1.25
 1.5
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a043485fa5a9510639cd8034392371aec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; setLinSpaced </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a linearly space vector. </p>
<p>The function fill *this with equally spaced values in the closed interval [low,high]. When size is set to 1, a vector of length 1 containing 'high' is returned.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aca96b3050ceeffaa781d3d4ee185bd1d" title="Sets a linearly space vector. ">setLinSpaced(Index, const Scalar&amp;, const Scalar&amp;)</a>, <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a196e62ee8a1fc3b4af631e955d650cfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; setOnes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to one.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">m.row(1).setOnes();</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 7  9 -5 -3
 1  1  1  1
 6 -3  0  9
 6  6  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a>, <a class="el" href="classEigen_1_1DenseBase.html#a2278addf9a3c977d40322571a0df8ac9">Ones()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab795c242db18862f502dfd9fa625c504"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; setRandom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to random values.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Matrix4i::Zero</a>();</div>
<div class="line">m.col(1).setRandom();</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 0  7  0  0
 0 -2  0  0
 0  6  0  0
 0  6  0  0
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a>, setRandom(Index), setRandom(Index,Index) </dd></dl>

</div>
</div>
<a class="anchor" id="a9053ca03ac251002768a54742be28fce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived &amp; setZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all coefficients in this expression to zero.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">m.row(1).setZero();</div>
<div class="line">cout &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment"> 7  9 -5 -3
 0  0  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1CwiseNullaryOp.html" title="Generic expression of a matrix where all coefficients are defined by a functor. ">CwiseNullaryOp</a>, <a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero()</a> </dd></dl>

<p>Referenced by <a class="el" href="classEigen_1_1SparseMatrixBase.html#a9c4cd92f386a6d4a583eac2a7637cc07">SparseMatrixBase&lt; CwiseBinaryOp&lt; BinaryOp, Lhs, Rhs &gt; &gt;::topRows()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a3b3fb530d3364ecef0bf9c9daf0983"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">internal::traits&lt; Derived &gt;::Scalar sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of all coefficients of *this</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>trace(), <a class="el" href="classEigen_1_1DenseBase.html#a6bdcbfa7e3b07d3246ad80de7170b0f5">prod()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a0af2b3991862a079e3efaef3e4d17d96">mean()</a> </dd></dl>

<p>References <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Eigen::Dynamic</a>.</p>

</div>
</div>
<a class="anchor" id="add3bfb296c2f8e29aac6037b16c2e8a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>OtherDerived::ThisConstantIsPrivateInPlainObjectBase</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>swaps *this with the expression <em>other</em>. </p>

</div>
</div>
<a class="anchor" id="a203951fa04396e45d2c38737943c2c55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1PlainObjectBase.html">PlainObjectBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>swaps *this with the matrix or array <em>other</em>. </p>

</div>
</div>
<a class="anchor" id="a3bed656b21b610ae88c51d281b5f8c44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SegmentReturnType tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of the last coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">RowVector4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.tail(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.tail(2) &lt;&lt; endl;</div>
<div class="line">v.tail(2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.tail(2):
6 6
Now the vector v is:
 7 -2  0  0
</pre><dl class="section note"><dt>Note</dt><dd>Even though the returned expression has dynamic size, in the case when it is applied to a fixed-size vector, it inherits a fixed maximal size, which means that evaluating it does not cause a dynamic memory allocation.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a3e433315822db2811a65e88c70672743">block(Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5e993c3ec78be489101773aa809ea52e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstSegmentReturnType tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a3bed656b21b610ae88c51d281b5f8c44">tail(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a392a82a3f895ed885a654ebaaffcf47f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FixedSegmentReturnType&lt;N&gt;::Type tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a fixed-size expression of the last coefficients of *this.</dd></dl>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of coefficients in the segment as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of coefficients in the segment as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga1b8ec6f0766c4900ed6f84f30c36669a">RowVector4i</a> v = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">RowVector4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the vector v:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is v.tail(2):&quot;</span> &lt;&lt; endl &lt;&lt; v.tail&lt;2&gt;() &lt;&lt; endl;</div>
<div class="line">v.tail&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the vector v is:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the vector v:
 7 -2  6  6
Here is v.tail(2):
6 6
Now the vector v is:
 7 -2  0  0
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a256bdc19a7d6b5d9cb16cb683b446e6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstFixedSegmentReturnType&lt;N&gt;::Type tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of tail&lt;int&gt;. </p>

</div>
</div>
<a class="anchor" id="a6f5fc5fe9d3fb70e62d4a9b1795704a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived&gt; topLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a top-left corner of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topLeftCorner(2, 2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.topLeftCorner(2, 2) &lt;&lt; endl;</div>
<div class="line">m.topLeftCorner(2, 2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topLeftCorner(2, 2):
 7  9
-2 -6
Now the matrix m is:
 0  0 -5 -3
 0  0  1  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af51f8dd1a464c0fe48182f7bab7ffab6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived&gt; topLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a6f5fc5fe9d3fb70e62d4a9b1795704a8">topLeftCorner(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="ae06d0a5c4008014fb717866aec8d30c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived, CRows, CCols&gt; topLeftCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size top-left corner of *this.</dd></dl>
<p>The template parameters CRows and CCols are the number of rows and columns in the corner.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topLeftCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.topLeftCorner&lt;2,2&gt;() &lt;&lt; endl;</div>
<div class="line">m.topLeftCorner&lt;2,2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topLeftCorner&lt;2,2&gt;():
 7  9
-2 -6
Now the matrix m is:
 0  0 -5 -3
 0  0  1  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a29c05f280e61cf18f5865b0065cc769a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived, CRows, CCols&gt; topLeftCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#ae06d0a5c4008014fb717866aec8d30c7">topLeftCorner&lt;int, int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="ae2942bfb77ac330fdd91d3f063686a63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived, CRows, CCols&gt; topLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a top-left corner of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em>cRows</em> should equal <em>CRows</em> unless <em>CRows</em> is <em>Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topLeftCorner&lt;2,Dynamic&gt;(2,2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.topLeftCorner&lt;2,<a class="code" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;(2,2) &lt;&lt; endl;</div>
<div class="line">m.topLeftCorner&lt;2,<a class="code" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;(2,2).<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topLeftCorner&lt;2,Dynamic&gt;(2,2):
 7  9
-2 -6
Now the matrix m is:
 0  0 -5 -3
 0  0  1  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

<p>References <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea247b0f8b0eb0bfd5e253eb1e4b61436b">DenseBase&lt; Derived &gt;::IsRowMajor</a>, and <a class="el" href="classEigen_1_1DenseBase.html#afa9be5679ab03d785820f2474c5ccc6ea7e22277c8f0a1a76dd0d6c62e366b59f">DenseBase&lt; Derived &gt;::IsVectorAtCompileTime</a>.</p>

</div>
</div>
<a class="anchor" id="a0b549d0127afc14bab07e4f440c4aeec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived, CRows, CCols&gt; topLeftCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a6f5fc5fe9d3fb70e62d4a9b1795704a8">topLeftCorner&lt;int, int&gt;(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a318006038c9becc5f9af003b7c77ea18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived&gt; topRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a dynamic-size expression of a top-right corner of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">cCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topRightCorner(2, 2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.topRightCorner(2, 2) &lt;&lt; endl;</div>
<div class="line">m.topRightCorner(2, 2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topRightCorner(2, 2):
-5 -3
 1  0
Now the matrix m is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8cd6c56ce974c092a0aa0f11ca1853cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived&gt; topRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a318006038c9becc5f9af003b7c77ea18">topRightCorner(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="ad0088b2c1ec4dbd677dd19f589777945"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived, CRows, CCols&gt; topRightCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size top-right corner of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>the number of rows in the corner </td></tr>
    <tr><td class="paramname">CCols</td><td>the number of columns in the corner</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topRightCorner&lt;2,2&gt;():&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.topRightCorner&lt;2,2&gt;() &lt;&lt; endl;</div>
<div class="line">m.topRightCorner&lt;2,2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topRightCorner&lt;2,2&gt;():
-5 -3
 1  0
Now the matrix m is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a3e433315822db2811a65e88c70672743">block&lt;int,int&gt;(Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abbe4b3135cc0afa4eee8d9db60c637c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived, CRows, CCols&gt; topRightCorner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#ad0088b2c1ec4dbd677dd19f589777945">topRightCorner&lt;int, int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a1bd671d8eea4781a3808d59718ba8b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Block.html">Block</a>&lt;Derived, CRows, CCols&gt; topRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a top-right corner of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CRows</td><td>number of rows in corner as specified at compile-time </td></tr>
    <tr><td class="paramname">CCols</td><td>number of columns in corner as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cRows</td><td>number of rows in corner as specified at run-time </td></tr>
    <tr><td class="paramname">cCols</td><td>number of columns in corner as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>This function is mainly useful for corners where the number of rows is specified at compile-time and the number of columns is specified at run-time, or vice versa. The compile-time and run-time information should not contradict. In other words, <em>cRows</em> should equal <em>CRows</em> unless <em>CRows</em> is <em>Dynamic</em>, and the same for the number of columns.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#ga43fa1a4828b3632224b0a959151ec232">Matrix4i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix4i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is m.topRightCorner&lt;2,Dynamic&gt;(2,2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; m.topRightCorner&lt;2,<a class="code" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;(2,2) &lt;&lt; endl;</div>
<div class="line">m.topRightCorner&lt;2,<a class="code" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Dynamic</a>&gt;(2,2).<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is m.topRightCorner&lt;2,Dynamic&gt;(2,2):
-5 -3
 1  0
Now the matrix m is:
 7  9  0  0
-2 -6  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8df165d3b3bedfe1386f20f3c2126973"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1Block.html">Block</a>&lt;const Derived, CRows, CCols&gt; topRightCorner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>cCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a318006038c9becc5f9af003b7c77ea18">topRightCorner&lt;int, int&gt;(Index, Index)</a>. </p>

</div>
</div>
<a class="anchor" id="afdfced3e157f74b3bc68892aad178424"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RowsBlockXpr topRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the top rows of *this.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line">Array44i a = Array44i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.topRows(2):&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; a.topRows(2) &lt;&lt; endl;</div>
<div class="line">a.topRows(2).setZero();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.topRows(2):
 7  9 -5 -3
-2 -6  1  0
Now the array a is:
 0  0  0  0
 0  0  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac77be6c2cf44abbb6f80496cbe14f2af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstRowsBlockXpr topRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#afdfced3e157f74b3bc68892aad178424">topRows(Index)</a>. </p>

</div>
</div>
<a class="anchor" id="a7e5159cea1bb46677c35df0dc06237a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NRowsBlockXpr&lt;N&gt;::Type topRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a block consisting of the top rows of *this.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>the number of rows in the block as specified at compile-time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of rows in the block as specified at run-time</td></tr>
  </table>
  </dd>
</dl>
<p>The compile-time and run-time information should not contradict. In other words, <em>n</em> should equal <em>N</em> unless <em>N</em> is <em>Dynamic</em>.</p>
<p>Example: </p>
<div class="fragment"><div class="line">Array44i a = Array44i::Random();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the array a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is a.topRows&lt;2&gt;():&quot;</span> &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; a.topRows&lt;2&gt;() &lt;&lt; endl;</div>
<div class="line">a.topRows&lt;2&gt;().<a class="code" href="classEigen_1_1DenseBase.html#a9053ca03ac251002768a54742be28fce">setZero</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the array a is:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the array a:
 7  9 -5 -3
-2 -6  1  0
 6 -3  0  9
 6  6  3  9
Here is a.topRows&lt;2&gt;():
 7  9 -5 -3
-2 -6  1  0
Now the array a is:
 0  0  0  0
 0  0  0  0
 6 -3  0  9
 6  6  3  9
</pre><dl class="section see"><dt>See Also</dt><dd>class <a class="el" href="classEigen_1_1Block.html" title="Expression of a fixed-size or dynamic-size block. ">Block</a>, <a class="el" href="classEigen_1_1DenseBase.html#a1dbaa2fc7b809720407130f48dfacf8f">block(Index,Index,Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9c4cd92f386a6d4a583eac2a7637cc07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ConstNRowsBlockXpr&lt;N&gt;::Type topRows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>N</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#afdfced3e157f74b3bc68892aad178424">topRows&lt;int&gt;()</a>. </p>

</div>
</div>
<a class="anchor" id="a3c187c30922fc5e42f208ae3eb0970ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1Transpose.html">Transpose</a>&lt; Derived &gt; transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the transpose of *this.</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__matrixtypedefs.html#gab837976997f1fdef130c5f47f712b9b0">Matrix2i</a> m = <a class="code" href="classEigen_1_1DenseBase.html#a8e759dafdd9ecc446d397b7f5435f60a">Matrix2i::Random</a>();</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the matrix m:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the transpose of m:&quot;</span> &lt;&lt; endl &lt;&lt; m.transpose() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Here is the coefficient (1,0) in the transpose of m:&quot;</span> &lt;&lt; endl</div>
<div class="line">     &lt;&lt; m.transpose()(1,0) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Let us overwrite this coefficient with the value 0.&quot;</span> &lt;&lt; endl;</div>
<div class="line">m.transpose()(1,0) = 0;</div>
<div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Now the matrix m is:&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">Here is the matrix m:
 7  6
-2  6
Here is the transpose of m:
 7 -2
 6  6
Here is the coefficient (1,0) in the transpose of m:
6
Let us overwrite this coefficient with the value 0.
Now the matrix m is:
 7  0
-2  6
</pre><dl class="section warning"><dt>Warning</dt><dd>If you want to replace a matrix by its own transpose, do <b>NOT</b> do this: <div class="fragment"><div class="line">* m = m.transpose(); <span class="comment">// bug!!! caused by aliasing effect</span></div>
<div class="line">* </div>
</div><!-- fragment --> Instead, use the <a class="el" href="classEigen_1_1DenseBase.html#a3689faf485a5e405a4fc9bf0e05564c9">transposeInPlace()</a> method: <div class="fragment"><div class="line">* m.transposeInPlace();</div>
<div class="line">* </div>
</div><!-- fragment --> which gives <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library. ">Eigen</a> good opportunities for optimization, or alternatively you can also do: <div class="fragment"><div class="line">* m = m.transpose().eval();</div>
<div class="line">* </div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a3689faf485a5e405a4fc9bf0e05564c9">transposeInPlace()</a>, adjoint() </dd></dl>

<p>Referenced by <a class="el" href="classEigen_1_1Hyperplane.html#aabfcda23a80edfd62387bb3d930f4b96">Hyperplane&lt; _Scalar, _AmbientDim, Options &gt;::Through()</a>.</p>

</div>
</div>
<a class="anchor" id="a228b8f9641f46db6e92e06374ea87918"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::<a class="el" href="classEigen_1_1Transpose.html">ConstTransposeReturnType</a> transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the const version of <a class="el" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose()</a>.</p>
<p>Make sure you read the warning for <a class="el" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose()</a> !</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a3689faf485a5e405a4fc9bf0e05564c9">transposeInPlace()</a>, adjoint() </dd></dl>

</div>
</div>
<a class="anchor" id="a3689faf485a5e405a4fc9bf0e05564c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void transposeInPlace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the "in place" version of <a class="el" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose()</a>: it replaces <code>*this</code> by its own transpose. Thus, doing </p>
<div class="fragment"><div class="line">* m.transposeInPlace();</div>
<div class="line">* </div>
</div><!-- fragment --><p> has the same effect on m as doing </p>
<div class="fragment"><div class="line">* m = m.transpose().eval();</div>
<div class="line">* </div>
</div><!-- fragment --><p> and is faster and also safer because in the latter line of code, forgetting the <a class="el" href="classEigen_1_1DenseBase.html#a6cb26f170dd440dfafe11117cf826334">eval()</a> results in a bug caused by <a class="el" href="group__TopicAliasing.html">aliasing</a>.</p>
<p>Notice however that this method is only useful if you want to replace a matrix by its own transpose. If you just need the transpose of a matrix, use <a class="el" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>if the matrix is not square, then <code>*this</code> must be a resizable matrix. This excludes (non-square) fixed-size matrices, block-expressions and maps.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a3c187c30922fc5e42f208ae3eb0970ee">transpose()</a>, adjoint(), adjointInPlace() </dd></dl>

<p>References <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Eigen::Dynamic</a>.</p>

</div>
</div>
<a class="anchor" id="a23fc4bf97168dee2516f85edcfd4cfe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryOp.html">CwiseUnaryOp</a>&lt;CustomUnaryOp, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; unaryExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomUnaryOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomUnaryOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a unary operator coefficient-wise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Functor implementing the unary operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CustomUnaryOp</td><td>Type of <em>func</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An expression of a custom coefficient-wise unary operator <em>func</em> of *this</dd></dl>
<p>The function <code>ptr_fun()</code> from the C++ standard library can be used to make functors out of normal functions.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="comment">// define function to be applied coefficient-wise</span></div>
<div class="line"><span class="keywordtype">double</span> ramp(<span class="keywordtype">double</span> x)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (x &gt; 0)</div>
<div class="line">    <span class="keywordflow">return</span> x;</div>
<div class="line">  <span class="keywordflow">else</span> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = Matrix4d::Random();</div>
<div class="line">  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a23fc4bf97168dee2516f85edcfd4cfe7">unaryExpr</a>(ptr_fun(ramp)) &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
  0.68  0.823      0      0
     0      0  0.108 0.0268
 0.566      0      0  0.904
 0.597  0.536  0.258  0.832
</pre><p>Genuine functors allow for more possibilities, for instance it may contain a state.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="comment">// define a custom template unary functor</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keyword">struct </span>CwiseClampOp {</div>
<div class="line">  CwiseClampOp(<span class="keyword">const</span> Scalar&amp; inf, <span class="keyword">const</span> Scalar&amp; sup) : m_inf(inf), m_sup(sup) {}</div>
<div class="line">  <span class="keyword">const</span> Scalar operator()(<span class="keyword">const</span> Scalar&amp; x)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x&lt;m_inf ? m_inf : (x&gt;m_sup ? m_sup : x); }</div>
<div class="line">  Scalar m_inf, m_sup;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = Matrix4d::Random();</div>
<div class="line">  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a23fc4bf97168dee2516f85edcfd4cfe7">unaryExpr</a>(CwiseClampOp&lt;double&gt;(-0.5,0.5)) &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
    0.5     0.5  -0.444   -0.27
 -0.211    -0.5   0.108  0.0268
    0.5   -0.33 -0.0452     0.5
    0.5     0.5   0.258     0.5
</pre><dl class="section see"><dt>See Also</dt><dd>class CwiseUnaryOp, class CwiseBinaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="aba9ae3923f6caa962ef3418d6872c369"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1CwiseUnaryView.html">CwiseUnaryView</a>&lt;CustomViewOp, const <a class="el" href="classEigen_1_1Matrix.html">Matrix</a>&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt; unaryViewExpr </td>
          <td>(</td>
          <td class="paramtype">const CustomViewOp &amp;&#160;</td>
          <td class="paramname"><em>func</em> = <code>CustomViewOp()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a custom coefficient-wise unary operator <em>func</em> of *this</dd></dl>
<p>The template parameter <em>CustomUnaryOp</em> is the type of the functor of the custom unary operator.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Eigen/Core&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>Eigen;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"></div>
<div class="line"><span class="comment">// define a custom template unary functor</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt;</div>
<div class="line"><span class="keyword">struct </span>CwiseClampOp {</div>
<div class="line">  CwiseClampOp(<span class="keyword">const</span> Scalar&amp; inf, <span class="keyword">const</span> Scalar&amp; sup) : m_inf(inf), m_sup(sup) {}</div>
<div class="line">  <span class="keyword">const</span> Scalar operator()(<span class="keyword">const</span> Scalar&amp; x)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> x&lt;m_inf ? m_inf : (x&gt;m_sup ? m_sup : x); }</div>
<div class="line">  Scalar m_inf, m_sup;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classEigen_1_1Matrix.html">Matrix4d</a> m1 = Matrix4d::Random();</div>
<div class="line">  cout &lt;&lt; m1 &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;becomes: &quot;</span> &lt;&lt; endl &lt;&lt; m1.<a class="code" href="classEigen_1_1MatrixBase.html#a23fc4bf97168dee2516f85edcfd4cfe7">unaryExpr</a>(CwiseClampOp&lt;double&gt;(-0.5,0.5)) &lt;&lt; endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">   0.68   0.823  -0.444   -0.27
 -0.211  -0.605   0.108  0.0268
  0.566   -0.33 -0.0452   0.904
  0.597   0.536   0.258   0.832
becomes: 
    0.5     0.5  -0.444   -0.27
 -0.211    -0.5   0.108  0.0268
    0.5   -0.33 -0.0452     0.5
    0.5     0.5   0.258     0.5
</pre><dl class="section see"><dt>See Also</dt><dd>class CwiseUnaryOp, class CwiseBinaryOp </dd></dl>

</div>
</div>
<a class="anchor" id="adf21a576b8f3a10bb141b8afd173b13d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoeffReturnType value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the unique coefficient of a 1x1 expression </dd></dl>

<p>Referenced by <a class="el" href="classEigen_1_1SparseMatrixBase.html#a9c4cd92f386a6d4a583eac2a7637cc07">SparseMatrixBase&lt; CwiseBinaryOp&lt; BinaryOp, Lhs, Rhs &gt; &gt;::topRows()</a>.</p>

</div>
</div>
<a class="anchor" id="af33f695c0e0ad5634ca73f19c347f7b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&#160;</td>
          <td class="paramname"><em>visitor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies the visitor <em>visitor</em> to the whole coefficients of the matrix or vector.</p>
<p>The template parameter <em>Visitor</em> is the type of the visitor and provides the following interface: </p>
<div class="fragment"><div class="line">* <span class="keyword">struct </span>MyVisitor {</div>
<div class="line">*   <span class="comment">// called for the first coefficient</span></div>
<div class="line">*   <span class="keywordtype">void</span> init(<span class="keyword">const</span> Scalar&amp; <a class="code" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>, <a class="code" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i, <a class="code" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> j);</div>
<div class="line">*   <span class="comment">// called for all other coefficients</span></div>
<div class="line">*   <span class="keywordtype">void</span> operator() (<span class="keyword">const</span> Scalar&amp; <a class="code" href="classEigen_1_1DenseBase.html#adf21a576b8f3a10bb141b8afd173b13d">value</a>, <a class="code" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> i, <a class="code" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a> j);</div>
<div class="line">* };</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>compared to one or two <em>for</em> <em>loops</em>, visitors offer automatic unrolling for small fixed size matrix.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd>minCoeff(Index*,Index*), maxCoeff(Index*,Index*), DenseBase::redux() </dd></dl>

<p>References <a class="el" href="namespaceEigen.html#adc9da5be31bdce40c25a92c27999c0e3">Eigen::Dynamic</a>.</p>

</div>
</div>
<a class="anchor" id="a724349af3e253b69a54d503931b52ec3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>nbCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a zero matrix.</dd></dl>
<p>The parameters <em>rows</em> and <em>cols</em> are the number of rows and of columns of the returned matrix. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> type.</p>
<p>This variant is meant to be used for dynamic-size matrix types. For fixed-size types, it is redundant to pass <em>rows</em> and <em>cols</em> as arguments, so <a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero()</a> should be used instead.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">MatrixXi::Zero</a>(2,3) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">0 0 0
0 0 0
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a39390955f1297dacb49ac94429f321fd">Zero(Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a39390955f1297dacb49ac94429f321fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType Zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEigen_1_1DenseBase.html#a4d4873e91be950c079f067fa97fd5c40">Index</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a zero vector.</dd></dl>
<p>The parameter <em>size</em> is the size of the returned vector. Must be compatible with this <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> type.</p>
<p>This is only for vectors (either row-vectors or column-vectors), i.e. matrices which are known at compile-time to have either one row or one column.</p>
<p>This variant is meant to be used for dynamic-size vector types. For fixed-size types, it is redundant to pass <em>size</em> as argument, so <a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero()</a> should be used instead.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">RowVectorXi::Zero</a>(4) &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">VectorXf::Zero</a>(2) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">0 0 0 0
0
0
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Zero()</a>, <a class="el" href="classEigen_1_1DenseBase.html#a724349af3e253b69a54d503931b52ec3">Zero(Index,Index)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2e36721b4833498b713e94a7948c6a29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt;::ConstantReturnType Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of a fixed-size zero matrix or vector.</dd></dl>
<p>This variant is only for fixed-size <a class="el" href="classEigen_1_1MatrixBase.html" title="Base class for all dense matrices, vectors, and expressions. ">MatrixBase</a> types. For dynamic-size types, you need to use the variants taking size arguments.</p>
<p>Example: </p>
<div class="fragment"><div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">Matrix2d::Zero</a>() &lt;&lt; endl;</div>
<div class="line">cout &lt;&lt; <a class="code" href="classEigen_1_1DenseBase.html#a2e36721b4833498b713e94a7948c6a29">RowVector4i::Zero</a>() &lt;&lt; endl;</div>
</div><!-- fragment --><p> Output: </p>
<pre class="fragment">0 0
0 0
0 0 0 0
</pre><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#a39390955f1297dacb49ac94429f321fd">Zero(Index)</a>, <a class="el" href="classEigen_1_1DenseBase.html#a724349af3e253b69a54d503931b52ec3">Zero(Index,Index)</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a3806d3f42de165878dace160e6aba40a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classEigen_1_1DenseBase.html">DenseBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Outputs the matrix, to the given stream.</p>
<p>If you wish to print the matrix with a format different than the default, use <a class="el" href="classEigen_1_1DenseBase.html#aa364b60e6a2a124ea7392e4c0550fb4e">DenseBase::format()</a>.</p>
<p>It is also possible to change the default format by defining EIGEN_DEFAULT_IO_FORMAT before including <a class="el" href="namespaceEigen.html" title="Namespace containing all symbols from the Eigen library. ">Eigen</a> headers. If not defined, this will automatically be defined to <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed. ">Eigen::IOFormat()</a>, that is the <a class="el" href="structEigen_1_1IOFormat.html" title="Stores a set of parameters controlling the way matrices are printed. ">Eigen::IOFormat</a> with default parameters.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classEigen_1_1DenseBase.html#aa364b60e6a2a124ea7392e4c0550fb4e">DenseBase::format()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Matrix_8h_source.html">Matrix.h</a></li>
<li><a class="el" href="Map_8h_source.html">Map.h</a></li>
<li><a class="el" href="RotationBase_8h_source.html">RotationBase.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="classEigen_1_1Matrix.html">Matrix</a></li>
    <li class="footer">Generated on Mon May 11 2015 06:37:47 for Eigen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://stats.sylphide-consulting.com/piwik/" : "http://stats.sylphide-consulting.com/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 20);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://stats.sylphide-consulting.com/piwik/piwik.php?idsite=20" style="border:0" alt="" /></p></noscript>
<!-- End Piwik Tracking Code -->
</body>
</html>
